<application>
  <component name="AppStorage">
    <histories>
      <item value="Remove a specific decorator instance. Same rules as {@linkplain List#remove(Object)}" />
      <item value="Note, passing true here will &lt;b&gt;not&lt;/b&gt; override minimum and maximum dates, if set. * This will only re-enable disabled dates." />
      <item value="Set days to be in a disabled state, or re-enabled.&lt;/p&gt;" />
      <item value="Set decoration options onto a facade to be applied to all relevant days" />
      <item value="Determine if a specific day should be decorated" />
      <item value="Decorate" />
      <item value="at Time" />
      <item value="a Calendar set to a day to focus the calendar on. Null will do nothing" />
      <item value="Set the calendar to a specific month or week based on a date." />
      <item value="a Date set to a day to select. Null to clear selection" />
      <item value="Add several day decorators" />
      <item value="附近" />
      <item value="if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null" />
      <item value="MIRROR" />
      <item value="CLAMP" />
      <item value="sorted" />
      <item value="第二" />
      <item value="Service Provider Interface" />
      <item value="resolve" />
      <item value="scope" />
      <item value="variant Data" />
      <item value="variant" />
      <item value="depends" />
      <item value="depends On" />
      <item value="Access Controller" />
      <item value="is Assignable From" />
      <item value="pending" />
      <item value="Processor" />
      <item value="graph" />
      <item value="Interface definition for a callback to be invoked when a hardware key event hasn't * been handled by the view hierarchy." />
      <item value="if set to true, the chart will avoid that the first and last label entry * in the chart &quot;clip&quot; off the edge of the chart or the screen" />
      <item value="illumination" />
      <item value="Dual" />
      <item value="statistical" />
      <item value="Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source Publisher satisfy a condition." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher will be the result of the function applied to the first item emitted by {@code o1} and the first item emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. &lt;p&gt; The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest items. &lt;p&gt;" />
      <item value="the number of elements to prefetch from each source Publisher" />
      <item value="delay errors from any of the source Publishers till the other terminates" />
      <item value="a function that, when applied to an item emitted by each of the source Publishers, results in an item that will be emitted by the resulting Publisher" />
      <item value="The operator subscribes to its sources in the order they are specified and completes eagerly if one of the sources is shorter than the rest while canceling the other sources. Therefore, it is possible those other sources will never be able to run to completion (and thus not calling {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if source A completes and B has been consumed and is about to complete, the operator detects A won't be sending further values and it will cancel B immediately. For example: &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt; {@code action1} will be called but {@code action2} won't. &lt;br&gt;To work around this termination property, use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion or cancellation." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher will be the result of the function applied to the first item emitted by {@code o1} and the first item emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. &lt;p&gt; The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest items." />
      <item value="applies this function in strict sequence, so the first item emitted by the new Publisher * will be the result of the function applied to the first item emitted by {@code o1} and the first item * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. * &lt;p&gt; * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest * items." />
      <item value="&lt;br&gt;To work around this termination property, * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion * or cancellation." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher * will be the result of the function applied to the first item emitted by {@code o1} and the first item * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. * &lt;p&gt; * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest * items." />
      <item value="Returns a Flowable that emits items that are the result of applying a specified function to pairs of * values, one each from the source Publisher and another specified Publisher." />
      <item value="The operator subscribes to its sources in the order they are specified and completes eagerly if * one of the sources is shorter than the rest while canceling the other sources. Therefore, it * is possible those other sources will never be able to run to completion (and thus not calling * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if * source A completes and B has been consumed and is about to complete, the operator detects A won't * be sending further values and it will cancel B immediately. For example: * &lt;pre&gt;&lt;code&gt;range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt; * {@code action1} will be called but {@code action2} won't. * &lt;br&gt;To work around this termination property, * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion * or cancellation." />
      <item value="the capacity hint for the buffer in the inner windows" />
      <item value="if true, errors from the current Flowable or the other Publisher is delayed until both terminate" />
      <item value="a function that combines the pairs of items from the two Publishers to generate the items to * be emitted by the resulting Publisher" />
      <item value="MILLISECOND&lt;/code&gt; is 250." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1157" />
        <entry key="ENGLISH" value="1158" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>