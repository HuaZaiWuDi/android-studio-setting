<application>
  <component name="AppStorage">
    <histories>
      <item value="The specified child already has a parent. You must call removeView() on the child's parent first." />
      <item value="container" />
      <item value="If the folder selected is an external media directory, this is unnecessary but otherwise other apps will not be able to access our images unless we scan them using [MediaScannerConnection]" />
      <item value="Image capture scanned into media store" />
      <item value="Callers should migrate to inserting items directly into * {@link MediaStore}, where they will be automatically scanned * after each mutation." />
      <item value="Broadcast Action: Request the media scanner to scan a file and add it to * the media database." />
      <item value="MediaScannerConnection provides a way for applications to pass a newly created or downloaded media file to the media scanner service The media scanner service will read metadata from the file and add the file to the media content provider. The MediaScannerConnectionClient provides an interface for the media scanner service to return the Uri for a newly scanned file to the client of the MediaScannerConnection class." />
      <item value="LENS FACING FRONT" />
      <item value="Optimizes capture pipeline to prioritize latency over image quality. When the capture * mode is set to MIN_LATENCY, images may capture faster but the image quality may be * reduced." />
      <item value="The executor in which the callback methods will be run." />
      <item value="Returns the set capture mode." />
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics." />
      <item value="Requires a camera with the specified lens facing." />
      <item value="Lens Facing" />
      <item value="Waits if necessary for at most the given time for the computation * to complete, and then retrieves its result, if available." />
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX. * * &lt;p&gt;This will initiate a close of every currently open camera." />
      <item value="Allows shutting down this {@link ProcessCameraProvider} instance so a new instance can be * retrieved by {@link #getInstance(Context)}." />
      <item value="Users can call {@link #createPoint(float, float)} to * create a {@link MeteringPoint} with x, y, default size. There is also another * variant, {@link #createPoint(float, float, float)} for apps that want to also specify size." />
      <item value="x to be converted." />
      <item value="The width/height is the width/height in surface orientation which defines an area (0, 0) * - (width, height) within which apps can specify metering points by * {@link #createPoint(float, float)}. Setting width and height to 1.0 will allow points to * be created by specifying normalized coordinates." />
      <item value="Creates the {@link SurfaceOrientedMeteringPointFactory} by width and height" />
      <item value="If more points are added than what current device supports for AF/AE/AWB, only the * first point and then in order up to the number of points supported on the device * will be enabled." />
      <item value="The points added here will be appended in order after the point set in builder * constructor." />
      <item value="&lt;p&gt;Metering mode is a combination of flags consisting of {@link #FLAG_AF}, * {@link #FLAG_AE}, and {@link #FLAG_AWB}. This combination indicates whether the * {@link MeteringPoint} is used to set AF(Auto Focus) region, AE(Auto Exposure) region * or AWB(Auto White Balance) region." />
      <item value="Adds another {@link MeteringPoint} with specified meteringMode." />
      <item value="A flag used in metering mode indicating the AF (Auto Focus) region is enabled. An autofocus * scan is also triggered when FLAG_AF is assigned." />
      <item value="A flag used in metering mode indicating the AWB (Auto White Balance) region is enabled." />
      <item value="A flag used in metering mode indicating the AE (Auto Exposure) region is enabled." />
      <item value="&lt;p&gt; This is used to apply additional configs that modifying the behavior of the camera and any attached {@link UseCase}. For example, this may limit the instances of CameraInternal that are used or configure the {@link ImageCapture} to use a {@link androidx.camera.core.impl.CaptureProcessor} in order to implement effects such as HDR or bokeh." />
      <item value="&lt;p&gt; This is used to apply additional configs that modifying the behavior of the camera and * any attached {@link UseCase}. For example, this may limit the instances of CameraInternal * that are used or configure the {@link ImageCapture} to use a * {@link androidx.camera.core.impl.CaptureProcessor} in order to implement effects such as * HDR or bokeh." />
      <item value="&lt;p&gt; A {@link Camera} is a logical camera which wraps one or more {@link CameraInternal}. * At any time, only one of the CameraInternal is actually being used, and it is up to the * implementation to determine which {@link CameraInternal} will be used. Certain * reconfigurations of the camera will cause the current CameraInternal camera to change. * However, it will be transparent to the {@link CameraControl} and {@link CameraInfo} * retrieved from {@link #getCameraControl()} and {@link #getCameraInfo()}." />
      <item value="Returns all of the {@link CameraInternal} instances represented by this Camera." />
      <item value="&lt;p&gt;The {@link CameraControl} provides various asynchronous operations like zoom, focus and * metering. {@link CameraControl} is ready to start operations immediately after use cases * are bound to the {@link Camera}. When all {@link UseCase}s are unbound, or when camera is * closing or closed because lifecycle onStop happens, the {@link CameraControl} will reject * all operations." />
      <item value="Returns information about this camera." />
      <item value="Set the extended config of the Camera and potentially reconfigure the camera." />
      <item value="Get the currently set extended config of the Camera." />
      <item value="Enable the torch or disable the torch." />
      <item value="Starts a focus and metering action configured by the {@link FocusMeteringAction}." />
      <item value="Captures a new still image for in memory access." />
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX." />
      <item value="Portrait" />
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics. * * &lt;p&gt;Multiple filters can be added. All filters will be applied by the order they were * added when the {@link CameraSelector} is used, and the first camera output from the * filters will be selected." />
      <item value="A {@link Future} that accepts completion listeners. Each listener has an associated executor, and * it is invoked using this executor once the future's computation is {@linkplain Future#isDone() * complete}. If the computation has already completed when the listener is added, the listener will * execute immediately. *" />
      <item value="&lt;p&gt;When the producer stops producing images, it may also stop producing images for other use cases, such as {@link Preview}, so it is important for the analyzer to keep up with frame rate, &lt;i&gt;on average&lt;/i&gt;. Failure to keep up with frame rate may lead to jank in the frame stream and a diminished user experience. If more time is needed for analysis on &lt;i&gt;some&lt;/i&gt; frames, consider increasing the image queue depth with {@link Builder#setImageQueueDepth(int)}." />
      <item value="&lt;p&gt;Once the producer has produced the number of images equal to the image queue depth, and none have been closed, the producer will stop producing images. Note that images may be queued internally and not be delivered to the analyzer until the last delivered image has been closed with {@link ImageProxy#close()}. These internally queued images will count towards the total number of images that the producer can provide at any one time." />
      <item value="&lt;p&gt;This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. Only one image will be delivered for analysis at a time. If more images are produced while that image is being analyzed, they will be dropped and not queued for delivery. Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the next latest image will be delivered." />
      <item value="Block the producer from generating new images." />
      <item value="PRODUCER" />
      <item value="&gt;The available values are {@link #STRATEGY_BLOCK_PRODUCER} and * {@link #STRATEGY_KEEP_ONLY_LATEST}. * * &lt;p&gt;If not set, the backpressure strategy will default to * {@link #STRATEGY_KEEP_ONLY_LATEST}. *" />
      <item value="This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. * Only one image will be delivered for analysis at a time. If more images are produced * while that image is being analyzed, they will be dropped and not queued for delivery. * Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the * next latest image will be delivered." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1579" />
        <entry key="ENGLISH" value="1580" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>