<application>
  <component name="AppStorage">
    <histories>
      <item value="if request limit per UID is exceeded." />
      <item value="if missing the appropriate permissions." />
      <item value="if {@code request} contains invalid network capabilitie" />
      <item value="Allow a previously configured network to be associated with. If &lt;code&gt;attemptConnect&lt;/code&gt; is true, an attempt to connect to the selected network is initiated. This may result in the asynchronous delivery of state change events." />
      <item value="Allow a previously configured network to be associated with. If * &lt;code&gt;attemptConnect&lt;/code&gt; is true, an attempt to connect to the selected * network is initiated. This may result in the asynchronous delivery * of state change events." />
      <item value="&lt;b&gt;Note:&lt;/b&gt; Network communication may not use Wi-Fi even if Wi-Fi is connected; * traffic may instead be sent through another network, such as cellular data, * Bluetooth tethering, or Ethernet. For example, traffic will never use a * Wi-Fi network that does not provide Internet access (e.g. a wireless * printer), if another network that does offer Internet access (e.g. * cellular data) is available. Applications that need to ensure that their * network traffic uses Wi-Fi should use APIs such as * {@link Network#bindSocket(java.net.Socket)}, * {@link Network#openConnection(java.net.URL)}, or * {@link ConnectivityManager#bindProcessToNetwork} to do so. *" />
      <item value="The {@link NetworkCallback} to be utilized for this request. Note * the callback must not be shared - it uniquely specifies this request. * The callback is invoked on the default internal Handler." />
      <item value="This {@link NetworkRequest} will live until released via * {@link #unregisterNetworkCallback(NetworkCallback)} or the calling application exits. A * version of the method which takes a timeout is * {@link #requestNetwork(NetworkRequest, NetworkCallback, int)}. * Status of the request can be followed by listening to the various * callbacks described in {@link NetworkCallback}. The {@link Network} * can be used to direct traffic to the network. * &lt;p&gt;It is presently unsupported to request a network with mutable * {@link NetworkCapabilities} such as * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL} * as these {@code NetworkCapabilities} represent states that a particular * network may never attain, and whether a network will attain these states * is unknown prior to bringing up the network so the framework does not * know how to go about satisfing a request with these capabilities." />
      <item value="* &lt;p&gt;This method requires the caller to hold either the * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission * or the ability to modify system settings as determined by * {@link android.provider.Settings.System#canWrite}.&lt;/p&gt;" />
      <item value="Need to switch wifi by user" />
      <item value="Indicates this network uses a Cellular transport." />
      <item value="Sets the value. If there are active observers, the value will be dispatched to them." />
      <item value="This method must be called from the main thread. If you need set a value from a background * thread, you can use {@link #postValue(Object)}" />
      <item value="If you called this method multiple times before a main thread executed a posted task, only * the last value would be dispatched." />
      <item value="The value &quot;b&quot; would be set at first and later the main thread would override it with * the value &quot;a&quot;." />
      <item value="Posts a task to a main thread to set the given value. So if you have a following code * executed in the main thread:" />
      <item value="识别" />
      <item value="Called when an attached input method calls * {@link InputConnection#performEditorAction(int) * InputConnection.performEditorAction()} * for this text view. The default implementation will call your action * listener supplied to {@link #setOnEditorActionListener}, or perform * a standard operation for {@link EditorInfo#IME_ACTION_NEXT * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE * EditorInfo.IME_ACTION_DONE}." />
      <item value="Add up fetch logic, almost like load more, but simpler." />
      <item value="Marquee" />
      <item value="The number of times to repeat the marquee animation. Only applied if the TextView has marquee enabled." />
      <item value="Boolean that controls whether a view can take focus while in touch mode. If this is true for a view, that view can gain focus when clicked on, and can keep focus if another view is clicked on that doesn't have this attribute set to true." />
      <item value="Calls the shared consumer with the success value sent via onSuccess for each * SingleObserver that subscribes to the current Single." />
      <item value="GRANTED" />
      <item value="2 exceptions occurred." />
      <item value="target" />
      <item value="目标" />
      <item value="语音" />
      <item value="门锁" />
      <item value="说明" />
      <item value="Identity" />
      <item value="Helper function to request a network with a particular legacy type." />
      <item value="apps should use the more versatile {@link #requestNetwork}, * {@link #registerNetworkCallback} or {@link #registerDefaultNetworkCallback} * functions instead for faster and more detailed updates about the network * changes they care about." />
      <item value="A change in network connectivity has occurred. A default connection has either * been established or lost. The NetworkInfo for the affected network is * sent as an extra; it should be consulted to see what kind of * connectivity event occurred." />
      <item value="未连接设备热点" />
      <item value="poll" />
      <item value="轮询" />
      <item value="需要手动切换wifi" />
      <item value="需要手动切xuyao " />
      <item value="需要手动切换" />
      <item value="授予" />
      <item value="Available" />
      <item value="Returns the position of the ViewHolder in terms of the latest layout pass." />
      <item value="Returns the Adapter position of the item represented by this ViewHolder." />
      <item value="This method is deprecated because its meaning is ambiguous due to the async * handling of adapter updates. You should use {@link #getLayoutPosition()} or * {@link #getAdapterPosition()} depending on your use case." />
      <item value="inflate" />
      <item value="Infalte" />
      <item value="安防" />
      <item value="shortcut" />
      <item value="Strong" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1263" />
        <entry key="ENGLISH" value="1264" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>