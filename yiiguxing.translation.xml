<application>
  <component name="AppStorage">
    <histories>
      <item value="Copies all of the elements from one list into another. After the * operation, the index of each copied element in the destination list * will be identical to its index in the source list. The destination * list must be at least as long as the source list. If it is longer, the * remaining elements in the destination list are unaffected. &lt;p&gt;" />
      <item value="Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator." />
      <item value="aggregate" />
      <item value="Perform the transaction action after onSaveInstanceState." />
      <item value="This is dangerous because the action can * be lost if the activity needs to later be restored from its state." />
      <item value="Delayed action must not be selected as the last action." />
      <item value="Delays cannot be continuous" />
      <item value="Favorite" />
      <item value="shortcut" />
      <item value="Delivery" />
      <item value="This position is deleted or do not have permission for this operation" />
      <item value="Supertypes of the following classes cannot be resolved. Please make sure you have the required dependencies in the classpath:" />
      <item value="Curtain" />
      <item value="Returns {@code true} if the FragmentManager's state has already been saved * by its host. Any operations that would change saved state should not be performed * if this method returns true. For example, any popBackStack() method, such as * {@link #popBackStackImmediate()} or any FragmentTransaction using * {@link FragmentTransaction#commit()} instead of * {@link FragmentTransaction#commitAllowingStateLoss()} will change * the state and will result in an error." />
      <item value="Perform" />
      <item value="If you don't want to lost the action:" />
      <item value="Perform the transaction action after onSaveInstanceState. * &lt;p&gt; * This is dangerous because the action can * be lost if the activity needs to later be restored from its state. * &lt;p&gt; * &lt;p&gt;" />
      <item value="Warning: Perform this popTo() action after onSaveInstanceState!" />
      <item value="在myguard 返回提示Tips中增加空格" />
      <item value="Virtual" />
      <item value="loading more or manual refresh" />
      <item value="CORRESPONDING" />
      <item value="Function of current event -&gt; target disposal event. ViewModel has a very simple lifecycle. * It is created and then later on cleared. So we only have two events and all subscriptions * will only be disposed at [ViewModelEvent.CLEARED]." />
      <item value="and access prior to that will result in IllegalArgumentException." />
      <item value="Returns a property delegate for a read/write property with a non-`null` value that is initialized not during * object construction time but at a later time. Trying to read the property before the initial value has been * assigned results in an exception." />
      <item value="Wrapper around layoutChildren() that handles animating changes caused by layout. * Animations work on the assumption that there are five different kinds of items * in play: * PERSISTENT: items are visible before and after layout * REMOVED: items were visible before layout and were removed by the app * ADDED: items did not exist before layout and were added by the app * DISAPPEARING: items exist in the data set before/after, but changed from * visible to non-visible in the process of layout (they were moved off * screen as a side-effect of other changes) * APPEARING: items exist in the data set before/after, but changed from * non-visible to visible in the process of layout (they were moved on * screen as a side-effect of other changes) * The overall approach figures out what items exist before/after layout and * infers one of the five above states for each of the items. Then the animations * are set up accordingly: * PERSISTENT views are animated via * {@link ItemAnimator#animatePersistence(ViewHolder, ItemHolderInfo, ItemHolderInfo)} * DISAPPEARING views are animated via * {@link ItemAnimator#animateDisappearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)} * APPEARING views are animated via * {@link ItemAnimator#animateAppearance(ViewHolder, ItemHolderInfo, ItemHolderInfo)} * and changed views are animated via * {@link ItemAnimator#animateChange(ViewHolder, ViewHolder, ItemHolderInfo, ItemHolderInfo)}." />
      <item value="dispatch" />
      <item value="설정한 요일/시간에만 실행됩니다." />
      <item value="category" />
      <item value="provides check for verifying if this element represents a null value or not." />
      <item value="Signals success with 0L value after the given delay for each SingleObserver." />
      <item value="Scenario" />
      <item value="sealed" />
      <item value="assign" />
      <item value="Returns whether the given CharSequence contains only digits." />
      <item value="Radio" />
      <item value="重复" />
      <item value="DURATION" />
      <item value="현재 신호세기" />
      <item value="현재" />
      <item value="신호세기" />
      <item value="강함" />
      <item value="약함" />
      <item value="현재 신호 강도" />
      <item value="건물명" />
      <item value="현재 신호 세기&lt;" />
      <item value="스마트 허브를 업데이트 중입니다. 잠시 후 다시 시도해주세요." />
      <item value="움직임 감지됨" />
      <item value="업데이트 실패, 다시 시도해 주세요." />
      <item value="업그레이드 실패，다시 시도해주세요." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="271" />
        <entry key="ENGLISH" value="272" />
        <entry key="KOREAN" value="92" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>