<application>
  <component name="AppStorage">
    <histories>
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or its parent has been &quot;activated&quot; meaning the user has currently marked it as being of interest. This is an alternative representation of state_checked for when the state should be propagated down the view hierarchy." />
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or drawable is in the last position in an ordered set. Actual usage may vary between views. Consult the host view documentation for details." />
      <item value="The specified child already has a parent. You must call removeView() on the child's parent first." />
      <item value="Creates a {@link ViewModelProvider}, which retains ViewModels while a scope of given * {@code fragment} is alive. More detailed explanation is in {@link ViewModel}." />
      <item value="Enqueues the given request at the front of the the init or task queue, depending * on whether the initialization is in progress, or not." />
      <item value="An instance of a request that waits for a notification or an indication. * There may be only a single instance of such request at a time as this is a blocking request." />
      <item value="Allow new requests when Bluetooth is enabled again. close() doesn't do it." />
      <item value="On older Android versions, after executing a command on secured attribute // of a device that is not bonded, let's say a write characteristic operation, // the system will start bonding. The BOND_BONDING and BOND_BONDED events will // be received, but the command will not be repeated automatically." />
      <item value="This method will be called if a remote device requires a non-'just works' pairing. * See PAIRING_* constants for possible options." />
      <item value="Device discovery is a heavyweight procedure. New connections to * remote Bluetooth devices should not be attempted while discovery is in * progress, and existing connections will experience limited bandwidth * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing * discovery. Discovery is not managed by the Activity, * but is run as a system service, so an application should always call * {@link BluetoothAdapter#cancelDiscovery()} even if it * did not directly request a discovery, just to be sure. * &lt;p&gt;Device discovery will only find remote devices that are currently * &lt;i&gt;discoverable&lt;/i&gt; (inquiry scan enabled). Many Bluetooth devices are * not discoverable by default, and need to be entered into a special mode. * &lt;p&gt;If Bluetooth state is not {@link #STATE_ON}, this API * will return false. After turning on Bluetooth, * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON} * to get the updated value." />
      <item value="The discovery process usually involves an inquiry scan of about 12 * seconds, followed by a page scan of each new device to retrieve its * Bluetooth name. * &lt;p&gt;This is an asynchronous call, it will return immediately. Register * for {@link #ACTION_DISCOVERY_STARTED} and {@link * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the * discovery starts and completes. Register for {@link * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices * are found." />
      <item value="Start the remote device discovery process." />
      <item value="Fails to start scan as BLE scan with the same settings is already started by the app" />
      <item value="Starts to listen the given {@code source} LiveData, {@code onChanged} observer will be called * when {@code source} value was changed." />
      <item value="yellow" />
      <item value="Category" />
      <item value="Check to see whether this activity is in the process of finishing, * either because you called {@link #finish} on it or someone else * has requested that it finished. This is often used in * {@link #onPause} to determine whether the activity is simply pausing or * completely finishing." />
      <item value="provided inputKeyingMaterial must be at least of size 1 and not null" />
      <item value="Only the original thread that created a view hierarchy can touch its views." />
      <item value="destination" />
      <item value="release" />
      <item value="listener This should be the listener object that was passed to * {@link #registerService}. It identifies the service that should be unregistered * and notifies of a successful or unsuccessful unregistration via the listener * callbacks. In API versions 20 and above, the listener object may be used for * another service registration once the callback has been called. In API versions &lt;= 19, * there is no entirely reliable way to know when a listener may be re-used, and a new * listener should be created for each service registration request." />
      <item value="* Unregister a service registered through {@link #registerService}. A successful * unregister is notified to the application with a call to" />
      <item value="lateinit property connection has not been initialized" />
      <item value="Error emitted when the connection to a specified device is already established or is being * established. In order to share the connection, share #establishConnection emissions." />
      <item value="PEER" />
      <item value="To prevent this exception from being emitted one must either:&lt;br&gt; * * always unsubscribe from the above mentioned Observable before subscribing again&lt;br&gt; * * {@link io.reactivex.Observable#share()} or {@link io.reactivex.Observable#publish()} the above mentioned * Observable so it will be subscribed only once" />
      <item value="Returns a new {@link ObservableSource} that multicasts (and shares a single subscription to) the original {@link ObservableSource}. As long as * there is at least one {@link Observer} this {@link ObservableSource} will be subscribed and emitting data. * When all subscribers have disposed it will dispose the source {@link ObservableSource}." />
      <item value="An exception being emitted from an {@link io.reactivex.Observable} returned by the function * {@link com.polidea.rxandroidble2.RxBleDevice#establishConnection(boolean)} or other establishConnection() overloads when this kind * of observable was already subscribed and {@link com.polidea.rxandroidble2.RxBleConnection} is currently being established or active." />
      <item value="A transformer which combines the {@code replay(1)}, {@code publish()}, and {@code refCount()} * operators." />
      <item value="Already connected to device with MAC address BC:E5:9F:48:96:D1" />
      <item value="TERMINATE" />
      <item value="Set how to log byte array values:" />
      <item value="Retry strategy allows retrying a long write operation. There are two supported scenarios: * - Once the failure happens you may re-emit the failure you've received, applying your own transformations like a delay or any other, * aiming to postpone the retry procedure. * - If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call * {@code onCompleted} or {@code onError} on the child subscription. The emission will be forwarded as an operation result." />
      <item value="a function that combines one item emitted by each of the source and collection ObservableSources and * returns an item to be emitted by the resulting ObservableSource" />
      <item value="Returns an Observable that emits the results of a specified function to the pair of values emitted by the * source ObservableSource and a specified collection ObservableSource." />
      <item value="so we zip three observables" />
      <item value="If any of the sources never produces an item but only terminates (normally or with an error), the * resulting sequence terminates immediately (normally or with all the errors accumulated till that point). * If that input source is also synchronous, other sources after it will not be subscribed to. *" />
      <item value="Combines two source ObservableSources by emitting an item that aggregates the latest values of each of the * source ObservableSources each time an item is received from either of the source ObservableSources, where this * aggregation is defined by a specified function." />
      <item value="previous batch of data was sent - we do not care if value emitted from the booleanObservable is TRUE or FALSE. But the value will be TRUE unless the previously sent data batch was the final one" />
      <item value="combine" />
      <item value="Lets assume that we do not know if the DC0 or DC1 will notify first. * It may also happen that Android OS will inform that the batch was transmitted after both DC0 and DC1 notify. *" />
      <item value="For the sake of this example lets assume that we have a Bluetooth Device that is retrieved by: *" />
      <item value="Setter for a retry strategy in case something goes wrong when writing data. If any {@link BleException} is raised, * a {@link WriteOperationRetryStrategy.LongWriteFailure} object is emitted. * {@link WriteOperationRetryStrategy.LongWriteFailure} contains both the {@link BleException} and the batch number * for which the write request failed. The {@link WriteOperationRetryStrategy.LongWriteFailure} emitted by the * writeOperationRetryStrategy will be used to retry the specified batch number write request." />
      <item value="the function that acknowledges writing of the batch of bytes. It takes * an {@link Observable} that emits a boolean value each time the byte array batch * has finished to write. {@link Boolean#TRUE} means that there are more items in the buffer, * {@link Boolean#FALSE} otherwise. If you want to delay the next batch use provided observable * and add some custom behavior (delay, waiting for a message from the device, etc.)" />
      <item value="Setter for a strategy used to mark batch write completed. Only after previous batch has finished, the next (if any left) can be * written. * If this is not specified - the next batch of bytes is written right after the previous one has finished. * * A bytes batch is a part (slice) of the original byte array to write. Imagine a byte array of {0, 1, 2, 3, 4} where the maximum * number of bytes that may be transmitted at once is 2. Then the original byte array will be transmitted in three batches: * {0, 1}, {2, 3}, {4} * * It is expected that the Observable returned from the writeOperationAckStrategy will emit exactly the same events as the source, * however you may delay them at your pace." />
      <item value="Auth" />
      <item value="Duplicate" />
      <item value="Blank" />
      <item value="SSL peer shut down incorrectly" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="49" />
        <entry key="ENGLISH" value="51" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
</application>