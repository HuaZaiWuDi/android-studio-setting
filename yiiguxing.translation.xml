<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="Minor GC" />
      <item value="及Minor GC" />
      <item value="Rescheduling" />
      <item value="(&lt; 5 while app visible)" />
      <item value="Rescheduling check for retained objects in 2000ms because found only 1 retained objects (&lt; 5 while app visible)" />
      <item value="reachability Fence" />
      <item value="END Android-changed: Reimplemented to accommodate a different GC and compiler." />
      <item value="This code is usually replaced by much faster intrinsic implementations. It will be executed for tests run with the access checks interpreter in ART, e.g. with --verify-soft-fail. Since this is a volatile store, it cannot easily be moved up past prior accesses, even if this method is inlined." />
      <item value="finalize count" />
      <item value="Leaving SinkHolder set to ref is unpleasant, since it keeps ref live until the next reachabilityFence call. This causes e.g. 036-finalizer to fail. Clear it again in a way that's unlikely to be optimizable. The fact that finalize_count is volatile makes it hard to move the test up." />
      <item value="Ensure that sink looks live to even a reasonably clever compiler." />
      <item value="Clears this reference object. Invoking this method will not cause this object to be enqueued." />
      <item value="referent – the object the new phantom reference will refer to q – the queue with which the reference is to be registered, or null if registration is not required" />
      <item value="It is possible to create a phantom reference with a null queue, but such a reference is completely useless: Its get method will always return null and, since it does not have a queue, it will never be enqueued." />
      <item value="Creates a new phantom reference that refers to the given object and is registered with the given queue." />
      <item value="In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null. Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable." />
      <item value="If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference." />
      <item value="Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. Phantom references are most often used for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism." />
      <item value="Gabage Collection" />
      <item value="Gabage " />
      <item value="Collection" />
      <item value="Gabage Collectio" />
      <item value="Gabage" />
      <item value="HotSpot" />
      <item value="무인 존재" />
      <item value="безлюдный" />
      <item value="Replace part of string after the last occurrence of given delimiter with the replacement string. If the string does not contain the delimiter, returns missingDelimiterValue which defaults to the original string." />
      <item value="Removes the given [delimiter] string from both the start and the end of this string if and only if it starts with and ends with the [delimiter]. Otherwise returns this string unchanged." />
      <item value="remove Surrounding" />
      <item value="The maximum number of substrings to return. Zero by default means no limit is set. To avoid ambiguous results when strings in delimiters have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in delimiters that is equal to a delimiter in this instance at that position." />
      <item value="a new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed." />
      <item value="strip Trailing Zeros" />
      <item value="missing Delimiter Value" />
      <item value="If this string ends with the given suffix, returns a copy of this string with the suffix removed. Otherwise, returns this string." />
      <item value="remove Suffix" />
      <item value="eturns a char sequence with content of this char sequence padded at the beginning to the specified length with the specified character or space." />
      <item value="Getter visibility must be the same as property visibility" />
      <item value="正常" />
      <item value="独立" />
      <item value="duli" />
      <item value="SDK" />
      <item value="is China Server" />
      <item value="is Chain Server" />
      <item value="Kotlin Migration" />
      <item value="Locale" />
      <item value="The language code, or the empty string if none is defined." />
      <item value="Vector" />
      <item value="Deprecated Use java.util.GregorianCalendar instead." />
      <item value="An alternative to the java.util.Calendar and java.util.GregorianCalendar classes. An instance of the Time class represents a moment in time, specified with second precision. It is modelled after struct tm. This class is not thread-safe and does not consider leap seconds. This class has a number of issues and it is recommended that java.util.GregorianCalendar is used instead. Known issues: For historical reasons when performing time calculations all arithmetic currently takes place using 32-bit integers. This limits the reliable time range representable from 1902 until 2037.See the wikipedia article on the Year 2038 problem for details. Do not rely on this behavior; it may change in the future. Calling switchTimezone(String) on a date that cannot exist, such as a wall time that was skipped due to a DST transition, will result in a date in 1969 (i.e. -1, or 1 second before 1st Jan 1970 UTC). Much of the formatting parsing assumes ASCII text and is therefore not suitable for use with non-ASCII scripts. No support for pseudo-zones like &quot;GMT-07:00&quot;." />
      <item value="Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2667" />
        <entry key="ENGLISH" value="2668" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="6" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="12" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658903898882" />
  </component>
</application>