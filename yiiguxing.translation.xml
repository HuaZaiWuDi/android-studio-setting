<application>
  <component name="AppStorage">
    <histories>
      <item value="Called each time the task queue gets cleared." />
      <item value="Set the 'operation in progress' flag, so any request made in onDeviceReady() // will not start new nextRequest() call." />
      <item value="after {@link BleManagerCallbacks#onDeviceReady(BluetoothDevice)} has been * called." />
      <item value="This method returns a {@link ConnectRequest} which can be used to set completion * and failure callbacks. The completion callback (done) will be called after the initialization * is complete, after {@link BleManagerCallbacks#onDeviceReady(BluetoothDevice)} has been * called." />
      <item value="is called in notifyDeviceDisconnected, which may enqueue new requests. // Setting this flag to false would allow to enqueue a new request before the // current one ends processing. The following line should not be uncommented." />
      <item value="Executes the next request. If the last element from the initialization queue has * been executed the {@link #onDeviceReady()} callback is called." />
      <item value="Callback indicating the connection parameters were updated. Works on Android 8+." />
      <item value="This method is called from the main thread when the services has been discovered and * the device is supported (has required service)." />
      <item value="This method should set up the request queue needed to initialize the profile. * Enabling Service Change indications for bonded devices is handled before executing this * queue. The queue may have requests that are not available, e.g. read an optional * service when it is not supported by the connected device. Such call will trigger * {@link Request#fail(FailCallback)}." />
      <item value="Chain of Causes for CompositeException In Order Received" />
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or its parent has been &quot;activated&quot; meaning the user has currently marked it as being of interest. This is an alternative representation of state_checked for when the state should be propagated down the view hierarchy." />
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or drawable is in the last position in an ordered set. Actual usage may vary between views. Consult the host view documentation for details." />
      <item value="The specified child already has a parent. You must call removeView() on the child's parent first." />
      <item value="Creates a {@link ViewModelProvider}, which retains ViewModels while a scope of given * {@code fragment} is alive. More detailed explanation is in {@link ViewModel}." />
      <item value="Enqueues the given request at the front of the the init or task queue, depending * on whether the initialization is in progress, or not." />
      <item value="An instance of a request that waits for a notification or an indication. * There may be only a single instance of such request at a time as this is a blocking request." />
      <item value="Allow new requests when Bluetooth is enabled again. close() doesn't do it." />
      <item value="On older Android versions, after executing a command on secured attribute // of a device that is not bonded, let's say a write characteristic operation, // the system will start bonding. The BOND_BONDING and BOND_BONDED events will // be received, but the command will not be repeated automatically." />
      <item value="This method will be called if a remote device requires a non-'just works' pairing. * See PAIRING_* constants for possible options." />
      <item value="Device discovery is a heavyweight procedure. New connections to * remote Bluetooth devices should not be attempted while discovery is in * progress, and existing connections will experience limited bandwidth * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing * discovery. Discovery is not managed by the Activity, * but is run as a system service, so an application should always call * {@link BluetoothAdapter#cancelDiscovery()} even if it * did not directly request a discovery, just to be sure. * &lt;p&gt;Device discovery will only find remote devices that are currently * &lt;i&gt;discoverable&lt;/i&gt; (inquiry scan enabled). Many Bluetooth devices are * not discoverable by default, and need to be entered into a special mode. * &lt;p&gt;If Bluetooth state is not {@link #STATE_ON}, this API * will return false. After turning on Bluetooth, * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON} * to get the updated value." />
      <item value="The discovery process usually involves an inquiry scan of about 12 * seconds, followed by a page scan of each new device to retrieve its * Bluetooth name. * &lt;p&gt;This is an asynchronous call, it will return immediately. Register * for {@link #ACTION_DISCOVERY_STARTED} and {@link * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the * discovery starts and completes. Register for {@link * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices * are found." />
      <item value="Start the remote device discovery process." />
      <item value="Fails to start scan as BLE scan with the same settings is already started by the app" />
      <item value="Starts to listen the given {@code source} LiveData, {@code onChanged} observer will be called * when {@code source} value was changed." />
      <item value="yellow" />
      <item value="Category" />
      <item value="Check to see whether this activity is in the process of finishing, * either because you called {@link #finish} on it or someone else * has requested that it finished. This is often used in * {@link #onPause} to determine whether the activity is simply pausing or * completely finishing." />
      <item value="provided inputKeyingMaterial must be at least of size 1 and not null" />
      <item value="Only the original thread that created a view hierarchy can touch its views." />
      <item value="destination" />
      <item value="release" />
      <item value="listener This should be the listener object that was passed to * {@link #registerService}. It identifies the service that should be unregistered * and notifies of a successful or unsuccessful unregistration via the listener * callbacks. In API versions 20 and above, the listener object may be used for * another service registration once the callback has been called. In API versions &lt;= 19, * there is no entirely reliable way to know when a listener may be re-used, and a new * listener should be created for each service registration request." />
      <item value="* Unregister a service registered through {@link #registerService}. A successful * unregister is notified to the application with a call to" />
      <item value="lateinit property connection has not been initialized" />
      <item value="Error emitted when the connection to a specified device is already established or is being * established. In order to share the connection, share #establishConnection emissions." />
      <item value="PEER" />
      <item value="To prevent this exception from being emitted one must either:&lt;br&gt; * * always unsubscribe from the above mentioned Observable before subscribing again&lt;br&gt; * * {@link io.reactivex.Observable#share()} or {@link io.reactivex.Observable#publish()} the above mentioned * Observable so it will be subscribed only once" />
      <item value="Returns a new {@link ObservableSource} that multicasts (and shares a single subscription to) the original {@link ObservableSource}. As long as * there is at least one {@link Observer} this {@link ObservableSource} will be subscribed and emitting data. * When all subscribers have disposed it will dispose the source {@link ObservableSource}." />
      <item value="An exception being emitted from an {@link io.reactivex.Observable} returned by the function * {@link com.polidea.rxandroidble2.RxBleDevice#establishConnection(boolean)} or other establishConnection() overloads when this kind * of observable was already subscribed and {@link com.polidea.rxandroidble2.RxBleConnection} is currently being established or active." />
      <item value="A transformer which combines the {@code replay(1)}, {@code publish()}, and {@code refCount()} * operators." />
      <item value="Already connected to device with MAC address BC:E5:9F:48:96:D1" />
      <item value="TERMINATE" />
      <item value="Set how to log byte array values:" />
      <item value="Retry strategy allows retrying a long write operation. There are two supported scenarios: * - Once the failure happens you may re-emit the failure you've received, applying your own transformations like a delay or any other, * aiming to postpone the retry procedure. * - If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call * {@code onCompleted} or {@code onError} on the child subscription. The emission will be forwarded as an operation result." />
      <item value="a function that combines one item emitted by each of the source and collection ObservableSources and * returns an item to be emitted by the resulting ObservableSource" />
      <item value="Returns an Observable that emits the results of a specified function to the pair of values emitted by the * source ObservableSource and a specified collection ObservableSource." />
      <item value="so we zip three observables" />
      <item value="If any of the sources never produces an item but only terminates (normally or with an error), the * resulting sequence terminates immediately (normally or with all the errors accumulated till that point). * If that input source is also synchronous, other sources after it will not be subscribed to. *" />
      <item value="Combines two source ObservableSources by emitting an item that aggregates the latest values of each of the * source ObservableSources each time an item is received from either of the source ObservableSources, where this * aggregation is defined by a specified function." />
      <item value="previous batch of data was sent - we do not care if value emitted from the booleanObservable is TRUE or FALSE. But the value will be TRUE unless the previously sent data batch was the final one" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="59" />
        <entry key="ENGLISH" value="61" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
</application>