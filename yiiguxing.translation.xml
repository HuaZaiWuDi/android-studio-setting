<application>
  <component name="AppStorage">
    <histories>
      <item value="graph" />
      <item value="Interface definition for a callback to be invoked when a hardware key event hasn't * been handled by the view hierarchy." />
      <item value="if set to true, the chart will avoid that the first and last label entry * in the chart &quot;clip&quot; off the edge of the chart or the screen" />
      <item value="illumination" />
      <item value="Dual" />
      <item value="statistical" />
      <item value="Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source Publisher satisfy a condition." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher will be the result of the function applied to the first item emitted by {@code o1} and the first item emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. &lt;p&gt; The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest items. &lt;p&gt;" />
      <item value="the number of elements to prefetch from each source Publisher" />
      <item value="delay errors from any of the source Publishers till the other terminates" />
      <item value="a function that, when applied to an item emitted by each of the source Publishers, results in an item that will be emitted by the resulting Publisher" />
      <item value="The operator subscribes to its sources in the order they are specified and completes eagerly if one of the sources is shorter than the rest while canceling the other sources. Therefore, it is possible those other sources will never be able to run to completion (and thus not calling {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if source A completes and B has been consumed and is about to complete, the operator detects A won't be sending further values and it will cancel B immediately. For example: &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt; {@code action1} will be called but {@code action2} won't. &lt;br&gt;To work around this termination property, use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion or cancellation." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher will be the result of the function applied to the first item emitted by {@code o1} and the first item emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. &lt;p&gt; The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest items." />
      <item value="applies this function in strict sequence, so the first item emitted by the new Publisher * will be the result of the function applied to the first item emitted by {@code o1} and the first item * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. * &lt;p&gt; * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest * items." />
      <item value="&lt;br&gt;To work around this termination property, * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion * or cancellation." />
      <item value="{@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher * will be the result of the function applied to the first item emitted by {@code o1} and the first item * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth. * &lt;p&gt; * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext} * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest * items." />
      <item value="Returns a Flowable that emits items that are the result of applying a specified function to pairs of * values, one each from the source Publisher and another specified Publisher." />
      <item value="The operator subscribes to its sources in the order they are specified and completes eagerly if * one of the sources is shorter than the rest while canceling the other sources. Therefore, it * is possible those other sources will never be able to run to completion (and thus not calling * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if * source A completes and B has been consumed and is about to complete, the operator detects A won't * be sending further values and it will cancel B immediately. For example: * &lt;pre&gt;&lt;code&gt;range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt; * {@code action1} will be called but {@code action2} won't. * &lt;br&gt;To work around this termination property, * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion * or cancellation." />
      <item value="the capacity hint for the buffer in the inner windows" />
      <item value="if true, errors from the current Flowable or the other Publisher is delayed until both terminate" />
      <item value="a function that combines the pairs of items from the two Publishers to generate the items to * be emitted by the resulting Publisher" />
      <item value="MILLISECOND&lt;/code&gt; is 250." />
      <item value="Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the * millisecond within the second." />
      <item value="Inverted" />
      <item value="The fractional part, if any, is rounded down towards zero." />
      <item value="the total range of values this axis covers" />
      <item value="Granted" />
      <item value="Unit" />
      <item value="evaluate" />
      <item value="评价" />
      <item value="spacing" />
      <item value="空隙" />
      <item value="only fill x values" />
      <item value="draws the x-labels on the specified y-position" />
      <item value="Electric" />
      <item value="axis label entries only used for centered labels" />
      <item value="the actual array of entries" />
      <item value="Compares value, xIndex and data of the entries. Returns true if entries * are equal in those points, false if not. Does not check by hash-code like * it's done by the &quot;equals&quot; method." />
      <item value="Sets up the axis values. Computes the desired number of labels between the two given extremes." />
      <item value="Checks if this DataSet contains the specified Entry. Returns true if so, * false if not. NOTE: Performance is pretty bad on this one, do not * over-use in performance critical situations." />
      <item value="Returns all Entry objects found at the given x-value with binary * search. An empty array if no Entry object at that x-value. * INFORMATION: This method does calculations at runtime. Do * not over-use in performance critical situations." />
      <item value="Set the visibility of this DataSet. If not visible, the DataSet will not * be drawn to the chart upon refreshing it." />
      <item value="Calculates the min and max y-values from the Entry closest to the given fromX to the Entry closest to the given toX value. * This is only needed for the autoScaleMinMax feature." />
      <item value="determine whether to round up/down/closest * if there is no Entry matching the provided x-value" />
      <item value="Search by closest to y-value" />
      <item value="If there are multiple y-values for the specified x-value," />
      <item value="CLOSEST" />
      <item value="Returns the first Entry object found at the given x-value with binary * search. * If the no Entry at the specified x-value is found, this method * returns the Entry at the closest x-value. * INFORMATION: This method does calculations at runtime. Do * not over-use in performance critical situations." />
      <item value="Returns the Entry object found at the given index (NOT xIndex) in the values array." />
      <item value="Returns the longest formatted label (in terms of characters), this axis * contains." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1124" />
        <entry key="ENGLISH" value="1125" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>