<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="Called whenever the contents of the back stack change." />
      <item value="Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that." />
      <item value="shutdown" />
      <item value="Create a scheduler with pool size equal to the available processor count and using least-recent worker selection policy." />
      <item value="Schedules work on the current thread but does not execute immediately. Work is put in a queue and executed after the current unit of work is completed." />
      <item value="rx2.purge-period-seconds (int): specifies the periodic purge interval of all Scheduler's backing thread pools, default is 1 second" />
      <item value="rx2.computation-threads (int): sets the number of threads in the computation() Scheduler, default is the number of available CPUs" />
      <item value="rx2.computation-priority (int): sets the thread priority of the computation() Scheduler, default is Thread.NORM_PRIORITY" />
      <item value="TRAMPOLINE" />
      <item value="COMPUTATION" />
      <item value="Static factory methods for returning standard Scheduler instances. The initial and runtime values of the various scheduler types can be overridden via the RxJavaPlugins.setInit(scheduler name)SchedulerHandler() and RxJavaPlugins.set(scheduler name)SchedulerHandler() respectively. Supported system properties (System.getProperty()): rx2.io-keep-alive-time (long): sets the keep-alive time of the io() Scheduler workers, default is IoScheduler.KEEP_ALIVE_TIME_DEFAULT rx2.io-priority (int): sets the thread priority of the io() Scheduler, default is Thread.NORM_PRIORITY rx2.computation-threads (int): sets the number of threads in the computation() Scheduler, default is the number of available CPUs rx2.computation-priority (int): sets the thread priority of the computation() Scheduler, default is Thread.NORM_PRIORITY rx2.newthread-priority (int): sets the thread priority of the newThread() Scheduler, default is Thread.NORM_PRIORITY rx2.single-priority (int): sets the thread priority of the single() Scheduler, default is Thread.NORM_PRIORITY rx2.purge-enabled (boolean): enables periodic purging of all Scheduler's backing thread pools, default is false rx2.purge-period-seconds (int): specifies the periodic purge interval of all Scheduler's backing thread pools, default is 1 second" />
      <item value="computation" />
      <item value="trampoline" />
      <item value="ViewType: 9 no such provider found，please use addItemProvider() first!" />
      <item value="HOLE" />
      <item value="This call will save the initial leftright drawables" />
      <item value="Query if horizontal scrolling is currently supported. The default implementation returns false. Returns: True if this LayoutManager can scroll the current contents horizontally" />
      <item value="Called when a child does not want this parent and its ancestors to intercept touch events with ViewGroup.onInterceptTouchEvent(MotionEvent). This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel. Params: disallowIntercept – True if the child does not want the parent to intercept touch events." />
      <item value="Air Conditioner Without State" />
      <item value="RING" />
      <item value="LINE" />
      <item value="OVAL" />
      <item value="RECTANGLE" />
      <item value="Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement onDraw(Canvas) instead of overriding this method. If you do need to override this method, call the superclass version." />
      <item value="erase Color" />
      <item value="m Drawing Cache" />
      <item value="Indicates the activation state of this view. Returns: true if the view is activated, false otherwise" />
      <item value="If this object has changed, as indicated by the hasChanged method, then notify all of its observers and then call the clearChanged method to indicate that this object has no longer changed. Each observer has its update method called with two arguments: this observable object and null. In other words, this method is equivalent to: notifyObservers(null)" />
      <item value="Marks this Observable object as having been changed; the hasChanged method will now return true." />
      <item value="Tests if this object has changed. Returns: true if and only if the setChanged method has been called more recently than the clearChanged method on this object; false otherwise. See Also: clearChanged(), setChanged()" />
      <item value="This method is called whenever the observed object is changed. An application calls an Observable object's notifyObservers method to have all the object's observers notified of the change. Params: o – the observable object. arg – an argument passed to the notifyObservers method." />
      <item value="Observable" />
      <item value="If this object has changed, as indicated by the &lt;code&gt;hasChanged&lt;code&gt; method, then notify all of its observers and then call the &lt;code&gt;clearChanged&lt;code&gt; method to indicate that this object has no longer changed. &lt;p&gt; Each observer has its &lt;code&gt;update&lt;code&gt; method called with two arguments: this observable object and &lt;code&gt;null&lt;code&gt;. In other words, this method is equivalent to:" />
      <item value="We don't want the Observer doing callbacks into arbitrary code while holding its own Monitor. The code where we extract each Observable from the Vector and store the state of the Observer needs synchronization, but notifying observers does not (should not). The worst result of any potential race-condition here is that: 1) a newly-added Observer will miss a notification in progress 2) a recently unregistered Observer will be wrongly notified when it doesn't care Android-changed: Call out to hasChanged() to figure out if something changes. Upstream code avoids calling the nonfinal hasChanged() from the synchronized block, but that would break compatibility for apps that override that method. if (!changed)" />
      <item value="This class represents an observable object, or &quot;data&quot; in the model-view paradigm. It can be subclassed to represent an object that the application wants to have observed. An observable object can have one or more observers. An observer may be any object that implements interface Observer. After an observable instance changes, an application calling the Observable's notifyObservers method causes all of its observers to be notified of the change by a call to their update method. The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose. Note that this notification mechanism has nothing to do with threads and is completely separate from the wait and notify mechanism of class Object. When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the equals method returns true for them. Since: JDK1.0 See Also: notifyObservers(), notifyObservers(Object), Observer, Observer.update(Observable, Object) Author: Chris Warth" />
      <item value="This method is called whenever the observed object is changed. An application calls an Observable object's notifyObservers method to have all the object's observers notified of the change." />
      <item value="RecyclerView calls this method right before clearing ViewHolder's internal data and sending it to RecycledViewPool. This way, if ViewHolder was holding valid information before being recycled, you can call RecyclerView.ViewHolder.getBindingAdapterPosition() to get its adapter position." />
      <item value="A view is recycled when a RecyclerView.LayoutManager decides that it no longer needs to be attached to its parent RecyclerView. This can be because it has fallen out of visibility or a set of cached views represented by views still attached to the parent RecyclerView. If an item view has large or expensive data bound to it such as large bitmaps, this may be a good place to release those resources. RecyclerView calls this method right before clearing ViewHolder's internal data and sending it to RecycledViewPool. This way, if ViewHolder was holding valid information before being recycled, you can call RecyclerView.ViewHolder.getBindingAdapterPosition() to get its adapter position." />
      <item value="Called when a view created by this adapter has been recycled." />
      <item value="The provider that owns this Lifecycle. Only WeakReference on LifecycleOwner is kept, so if somebody leaks Lifecycle, they won't leak the whole Fragment Activity. However, to leak Lifecycle object isn't great idea neither, because it keeps strong references on all other listeners, so you'll leak all of them as well." />
      <item value="m New Event Occurred" />
      <item value="backward Pass" />
      <item value="newest" />
      <item value="ceil" />
      <item value="delta" />
      <item value="remaining Space" />
      <item value="More optimized set the click listener inside the view holder" />
      <item value="TODO: Consider the case mFlexWrap is set to nowrap and view is recycled individually" />
      <item value="Echelon" />
      <item value="Skid Right" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2505" />
        <entry key="ENGLISH" value="2506" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657962795895" />
  </component>
</application>