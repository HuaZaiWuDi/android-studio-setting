<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="distinct By" />
      <item value="Roller Shade" />
      <item value="Called when a view created by this holder has been attached to a window. simple to solve item will layout using all setFullSpan Params: holder -" />
      <item value="This is a function of current event -&gt; target disposal event. That is to say that if event &quot;Attach&quot; returns &quot;Detach&quot;, then any stream subscribed to during Attach will autodispose on Detach." />
      <item value="Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch any more events. For instance, for an android.app.Activity, this state is reached right before Activity's onDestroy call." />
      <item value="Sets the current state and notifies the observers. Note that if the currentState is the same state as the last call to this method, calling this method has no effect. Params: event – The event that was received" />
      <item value="Dispatch a window visibility change down the view hierarchy. ViewGroups should override to route to their children. Params: visibility – The new visibility of the window. See Also: onWindowVisibilityChanged(int)" />
      <item value="Called when the window containing has change its visibility (between GONE, INVISIBLE, and VISIBLE). Note that this tells you whether or not your window is being made visible to the window manager; this does not tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible. Params: visibility – The new visibility of the window." />
      <item value="The specified message queue synchronization barrier token has not been posted or has already been removed." />
      <item value="T Current PLAYBACK STATE" />
      <item value="set Shadow Color" />
      <item value="set Scrim Color" />
      <item value="Inconsistency detected" />
      <item value="圆角" />
      <item value="yun" />
      <item value="quan'j" />
      <item value="second Progress Color" />
      <item value="jump Drawables To Current State" />
      <item value="crash wasn't handled by all associated webviews, triggering application crash." />
      <item value="fault addr " />
      <item value="Return true if the fragment is currently added to its activity." />
      <item value="Return true if the fragment has been explicitly detached from the UI. That is, FragmentTransaction.detach(Fragment) has been used on it." />
      <item value="旋转" />
      <item value="xuan'z" />
      <item value="选择" />
      <item value="reverse" />
      <item value="略过" />
      <item value="nue'guo" />
      <item value="luo'guo" />
      <item value="luo" />
      <item value="跳" />
      <item value="跳过" />
      <item value="the delay amount" />
      <item value="Applies FitCenter and to all default types, DownsampleStrategy.FIT_CENTER to image types, and throws an exception if asked to transform an unknown type. This will override previous calls to dontTransform() and previous calls to downsample(DownsampleStrategy). See Also: transform(Class, Transformation), optionalFitCenter()" />
      <item value="Applies CenterCrop to all default types, and ignores unknown types. This will override previous calls to dontTransform(). See Also: optionalTransform(Class, Transformation), centerCrop()" />
      <item value="Called when a view created by this BaseItemProvider has been attached to a window. 当此BaseItemProvider出现在屏幕上的时候，会调用此方法" />
      <item value="command" />
      <item value="联动" />
      <item value="re" />
      <item value="Returns the adapter position of the first visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. (setReverseLayout(boolean)). Views are sorted by their positions in the adapter, not in the layout." />
      <item value="accept Partially Visible" />
      <item value="Find the topmost view under the given point. Params: x – Horizontal position in pixels to search y – Vertical position in pixels to search" />
      <item value="Lay out all relevant child views from the given adapter. The LayoutManager is in charge of the behavior of item animations. By default, RecyclerView has a non-null ItemAnimator, and simple item animations are enabled. This means that addremove operations on the adapter will result in animations to add new or appearing items, removed or disappearing items, and moved items. If a LayoutManager returns false from supportsPredictiveItemAnimations(), which is the default, and runs a normal layout operation during onLayoutChildren(RecyclerView.Recycler, RecyclerView.State), the RecyclerView will have enough information to run those animations in a simple way. For example, the default ItemAnimator, DefaultItemAnimator, will simply fade views in and out, whether they are actually addedremoved or whether they are moved on or off the screen due to other addremove operations. A LayoutManager wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the LayoutManager should return true from supportsPredictiveItemAnimations() and add additional logic to onLayoutChildren(RecyclerView.Recycler, RecyclerView.State). Supporting predictive animations means that onLayoutChildren(RecyclerView.Recycler, RecyclerView.State) will be called twice; once as a &quot;pre&quot; layout step to determine where items would have been prior to a real layout, and again to do the &quot;real&quot; layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, removed items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other views, including views that were not previously onscreen (referred to as APPEARING views), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed views. The second layout pass is the real layout in which only non-removed views will be used. The only additional requirement during this pass is, if supportsPredictiveItemAnimations() returns true, to note which views exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING views), and to positionlayout those views appropriately, without regard to the actual bounds of the RecyclerView. This allows the animation system to know the location to which to animate these disappearing views. The default LayoutManager implementations for RecyclerView handle all of these requirements for animations already. Clients of RecyclerView can either use one of these layout managers directly or look at their implementations of onLayoutChildren() to see how they account for the APPEARING and DISAPPEARING views." />
      <item value="Scroll to the specified adapter position with the given offset from resolved layout start. Resolved layout start depends on getReverseLayout(), ViewCompat.getLayoutDirection(View) and getStackFromEnd()." />
      <item value="Scroll the RecyclerView to make the position visible. RecyclerView will scroll the minimum amount that is necessary to make the target position visible. If you are looking for a similar behavior to android.widget.ListView.setSelection(int) or android.widget.ListView.setSelectionFromTop(int, int), use scrollToPositionWithOffset(int, int)." />
      <item value="compute Horizontal Scroll Range" />
      <item value="Returns the adapter position of the last fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges. Returns: The adapter position of the last fully visible view or RecyclerView.NO_POSITION if there aren't any visible items." />
      <item value="Returns the first child that is visible in the provided index range, i.e. either partially or fully visible depending on the arguments provided. Completely invisible children are not acceptable by this method, but could be returned using findOnePartiallyOrCompletelyInvisibleChild" />
      <item value="Offset the bounds of all child views by dy pixels. Useful for implementing simple scrolling in LayoutManagers." />
      <item value="Called when a view is attached to the RecyclerView. Params: view – The View which is attached to the RecyclerView" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2365" />
        <entry key="ENGLISH" value="2366" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1656136099324" />
  </component>
</application>