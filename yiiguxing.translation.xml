<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="If non-null, this is the name of a previous back state to look for; if found, all states up to that state will be popped. The POP_BACK_STACK_INCLUSIVE flag can be used to control whether the named state itself is popped. If null, only the top state is popped." />
      <item value="returns the position of the y-labels" />
      <item value="If this is set to true, the y-axis is inverted which means that low values are on top of the chart, high values on bottom. Params: enabled –" />
      <item value="returns true if drawing the bottom y-axis label entry is enabled Returns:" />
      <item value="Request abbreviated scan results which contain the device, rssi and scan timestamp. Note: It is possible for an application to get more scan results than it asked for, if there are multiple apps using this type." />
      <item value="if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown." />
      <item value="if the value of millis is negative" />
      <item value="ReentrantLock" />
      <item value="Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call). Params: o – element to be removed from this queue, if present Returns: true if this queue changed as a result of the call" />
      <item value="Removes a node from head of queue. Returns: the node" />
      <item value="Condition" />
      <item value="lock Interruptibly" />
      <item value="Signals a waiting take. Called only from putoffer (which do not otherwise ordinarily lock takeLock.)" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs." />
      <item value="Wakes up one waiting thread. If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from await. Implementation Considerations An implementation may (and typically does) require that the current thread hold the lock associated with this Condition when this method is called. Implementations must document this precondition and any actions taken if the lock is not held. Typically, an exception such as IllegalMonitorStateException will be thrown." />
      <item value="signal" />
      <item value="get And Increment" />
      <item value="capacity" />
      <item value="Note that count is used in wait guard even though it is not protected by lock. This works because count can only decrease at this point (all other puts are shut out by lock), and we (or some other waiting put) are signalled if it ever changes from capacity. Similarly for all other uses of count in other wait guards." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods." />
      <item value="Examine" />
      <item value="not applicable not applicable" />
      <item value="Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available." />
      <item value="Retrieves and removes the head of this queue, waiting if necessary until an element becomes available." />
      <item value="Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available." />
      <item value="Inserts the specified element into this queue, waiting if necessary for space to become available. Params: e – the element to add" />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use offer." />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception." />
      <item value="Called whenever the contents of the back stack change." />
      <item value="Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that." />
      <item value="shutdown" />
      <item value="Create a scheduler with pool size equal to the available processor count and using least-recent worker selection policy." />
      <item value="Schedules work on the current thread but does not execute immediately. Work is put in a queue and executed after the current unit of work is completed." />
      <item value="rx2.purge-period-seconds (int): specifies the periodic purge interval of all Scheduler's backing thread pools, default is 1 second" />
      <item value="rx2.computation-threads (int): sets the number of threads in the computation() Scheduler, default is the number of available CPUs" />
      <item value="rx2.computation-priority (int): sets the thread priority of the computation() Scheduler, default is Thread.NORM_PRIORITY" />
      <item value="TRAMPOLINE" />
      <item value="COMPUTATION" />
      <item value="Static factory methods for returning standard Scheduler instances. The initial and runtime values of the various scheduler types can be overridden via the RxJavaPlugins.setInit(scheduler name)SchedulerHandler() and RxJavaPlugins.set(scheduler name)SchedulerHandler() respectively. Supported system properties (System.getProperty()): rx2.io-keep-alive-time (long): sets the keep-alive time of the io() Scheduler workers, default is IoScheduler.KEEP_ALIVE_TIME_DEFAULT rx2.io-priority (int): sets the thread priority of the io() Scheduler, default is Thread.NORM_PRIORITY rx2.computation-threads (int): sets the number of threads in the computation() Scheduler, default is the number of available CPUs rx2.computation-priority (int): sets the thread priority of the computation() Scheduler, default is Thread.NORM_PRIORITY rx2.newthread-priority (int): sets the thread priority of the newThread() Scheduler, default is Thread.NORM_PRIORITY rx2.single-priority (int): sets the thread priority of the single() Scheduler, default is Thread.NORM_PRIORITY rx2.purge-enabled (boolean): enables periodic purging of all Scheduler's backing thread pools, default is false rx2.purge-period-seconds (int): specifies the periodic purge interval of all Scheduler's backing thread pools, default is 1 second" />
      <item value="computation" />
      <item value="trampoline" />
      <item value="ViewType: 9 no such provider found，please use addItemProvider() first!" />
      <item value="HOLE" />
      <item value="This call will save the initial leftright drawables" />
      <item value="Query if horizontal scrolling is currently supported. The default implementation returns false. Returns: True if this LayoutManager can scroll the current contents horizontally" />
      <item value="Called when a child does not want this parent and its ancestors to intercept touch events with ViewGroup.onInterceptTouchEvent(MotionEvent). This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel. Params: disallowIntercept – True if the child does not want the parent to intercept touch events." />
      <item value="Air Conditioner Without State" />
      <item value="RING" />
      <item value="LINE" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2536" />
        <entry key="ENGLISH" value="2537" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657962795895" />
  </component>
</application>