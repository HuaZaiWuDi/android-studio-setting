<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="SDK" />
      <item value="is China Server" />
      <item value="is Chain Server" />
      <item value="Kotlin Migration" />
      <item value="Locale" />
      <item value="The language code, or the empty string if none is defined." />
      <item value="Vector" />
      <item value="Deprecated Use java.util.GregorianCalendar instead." />
      <item value="An alternative to the java.util.Calendar and java.util.GregorianCalendar classes. An instance of the Time class represents a moment in time, specified with second precision. It is modelled after struct tm. This class is not thread-safe and does not consider leap seconds. This class has a number of issues and it is recommended that java.util.GregorianCalendar is used instead. Known issues: For historical reasons when performing time calculations all arithmetic currently takes place using 32-bit integers. This limits the reliable time range representable from 1902 until 2037.See the wikipedia article on the Year 2038 problem for details. Do not rely on this behavior; it may change in the future. Calling switchTimezone(String) on a date that cannot exist, such as a wall time that was skipped due to a DST transition, will result in a date in 1969 (i.e. -1, or 1 second before 1st Jan 1970 UTC). Much of the formatting parsing assumes ASCII text and is therefore not suitable for use with non-ASCII scripts. No support for pseudo-zones like &quot;GMT-07:00&quot;." />
      <item value="Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices." />
      <item value="load Factor" />
      <item value="The load factor for the hash table." />
      <item value="zero initial threshold signifies using defaults" />
      <item value="initial capacity was placed in threshold" />
      <item value="The maximum capacity, used if a higher value is implicitly specified by either of the constructors with arguments. MUST be a power of two &lt;= 1&lt;&lt;30." />
      <item value="replacement Tree Node" />
      <item value="treeify Bin" />
      <item value="only If Absent" />
      <item value="existing mapping for key" />
      <item value="Replaces all linked nodes in bin at index for given hash unless table is too small, in which case resizes instead." />
      <item value="The RecyclerView is currently animating to a final position while not under outside control. See Also: getScrollState()" />
      <item value="SCROLL STATE SETTLING" />
      <item value="Scroll has initiated, prevent parents from intercepting" />
      <item value="find Intercepting On Item Touch Listener" />
      <item value="The adapter position of the first visible item or RecyclerView.NO_POSITION if there aren't any visible items." />
      <item value="Returns the adapter position of the first visible view. This position does not include adapter changes that were dispatched after the last layout pass." />
      <item value="laid Out Range" />
      <item value="laid Out Area" />
      <item value="smooth scrollbar enabled. try to estimate better." />
      <item value="The total horizontal range represented by the vertical scrollbar" />
      <item value="verride this method if you want to support scroll bars." />
      <item value="The total vertical range represented by the vertical scrollbar" />
      <item value="The vertical offset of the scrollbar's thumb" />
      <item value="The horizontal extent of the scrollbar's thumb" />
      <item value="We're already in this state, assume our ancestors are too" />
      <item value="True if the child does not want the parent to intercept touch events." />
      <item value="The horizontal offset of the scrollbar's thumb" />
      <item value="The range is expressed in arbitrary units that must be the same as the units used by computeHorizontalScrollRange() and computeHorizontalScrollExtent()." />
      <item value="Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the length of the thumb within the scrollbar's track." />
      <item value="SCROLL STATE DRAGGING" />
      <item value="Check if this view can be scrolled horizontally in a certain direction. Params: direction â€“ Negative to check scrolling left, positive to check scrolling right. Returns: true if this view can be scrolled in the specified direction, false otherwise." />
      <item value="has Queued Predecessors" />
      <item value="SIGNAL" />
      <item value="value to indicate the next acquireShared should unconditionally propagate." />
      <item value="cquireShared should unconditionally propagat" />
      <item value="condition" />
      <item value="unparking" />
      <item value="waitStatus value to indicate successor's thread needs unparking." />
      <item value="ParkAfterFailedAcquire" />
      <item value="Park" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2621" />
        <entry key="ENGLISH" value="2621" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658395529321" />
  </component>
</application>