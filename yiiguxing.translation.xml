<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="471" />
    <option name="newTranslationDialogY" value="-595" />
    <histories>
      <item value="Renderscript" />
      <item value="Transform" />
      <item value="不支持" />
      <item value="support" />
      <item value="s" />
      <item value="支持" />
      <item value="Supertypes of the following classes cannot be resolved." />
      <item value="Supertypes of the following classes cannot be resolved. Please make sure you have the required dependencies in the classpath: class com.lumi.module.module_ble.model.ble.AqaraBleManager, unresolved supertypes: no.nordicsemi.android.ble.livedata.ObservableBleManager" />
      <item value="on Terminate" />
      <item value="ACCESS" />
      <item value="provisioned" />
      <item value="provis" />
      <item value="pr" />
      <item value="Nsd Manager" />
      <item value="Diagram attachment access error: cannot display diagram" />
      <item value="capability" />
      <item value="plugin" />
      <item value="plu" />
      <item value="prg" />
      <item value="Caused by: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 1322 path $.androidAccessLink" />
      <item value="p" />
      <item value="canary&#10;" />
      <item value="canary" />
      <item value="can" />
      <item value="Matrix" />
      <item value="onDraw" />
      <item value="onMeasure" />
      <item value="Barrier" />
      <item value="Recognize" />
      <item value="Returns a set containing all elements that are contained by both this set and the specified collection" />
      <item value="The elements in the resulting list are in the same order as they were in the source collection." />
      <item value="Returns a list containing only elements from the given collection having distinct keys returned by the given selector function." />
      <item value="Consider the following scenario: we have 2 instances of LiveData, let's name them liveData1 and liveData2, and we want to merge their emissions in one object: liveDataMerger. Then, liveData1 and liveData2 will become sources for the MediatorLiveData liveDataMerger and every time onChanged callback is called for either of them, we set a new value in liveDataMerger." />
      <item value="Mediator Live Data" />
      <item value="undefined" />
      <item value="下拉浏览" />
      <item value="Starline" />
      <item value="Un Peek" />
      <item value="次要" />
      <item value="ci" />
      <item value="Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional type" />
      <item value="internal" />
      <item value="网关可用" />
      <item value="net" />
      <item value="if request contains invalid network capabilities" />
      <item value="if request limit per UID is exceeded" />
      <item value="request Network" />
      <item value="Token has expired" />
      <item value="is not specified." />
      <item value="wifi Name" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1733" />
        <entry key="ENGLISH" value="1729" />
        <entry key="FRENCH" value="2" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1621823694379" />
  </component>
</application>