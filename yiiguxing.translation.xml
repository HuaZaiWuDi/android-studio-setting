<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="Returns a string having leading and trailing whitespace removed." />
      <item value="Returns a string having trailing characters matching the predicate removed." />
      <item value="trim End" />
      <item value="a new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed." />
      <item value="Returns a new BigDecimal instance with the same value as this but with a unscaled value where the trailing zeros have been removed. If the unscaled value of this has n trailing zeros, then the scale and the precision of the result has been reduced by n. Returns: a new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed." />
      <item value="Queued" />
      <item value="Abstract Queued Synchronizer" />
      <item value="old Tail" />
      <item value="set Exclusive Owner Thread" />
      <item value="Returns the current value of synchronization state. This operation has memory semantics of a volatile read." />
      <item value="nonfair Try Acquire" />
      <item value="Acquire" />
      <item value="Return the last value given to setDebugUnregister." />
      <item value="swap" />
      <item value="Atomically sets the value to the given updated value if the current value == the expected value." />
      <item value="compare And Set" />
      <item value="Subscribes to the source Flowable on the specified Scheduler and makes sure downstream requests are scheduled there as well." />
      <item value="Atomic Reference" />
      <item value="Asynchronously subscribes Subscribers to this Publisher on the specified Scheduler. If there is a create(FlowableOnSubscribe, BackpressureStrategy) type source up in the chain, it is recommended to use subscribeOn(scheduler, false) instead to avoid same-pool deadlock because requests may pile up behind an eagerblocking emitter." />
      <item value="scheduler – the Scheduler to perform subscription actions on Returns: the source Publisher modified so that its subscriptions happen on the specified Scheduler" />
      <item value="Backpressure: The operator doesn't interfere with backpressure which is determined by the source Publisher's backpressure behavior. Scheduler: You specify which Scheduler this operator will use." />
      <item value="Called after migrations execute to perform additional work. Params: database – The SQLite database." />
      <item value="Set of conflict handling strategies for various Dao methods." />
      <item value="OnConflict strategy constant to abort the transaction. The transaction is rolled back." />
      <item value="OnConflict strategy constant to ignore the conflict. An Insert DAO method that returns the inserted rows ids will return -1 for rows that are not inserted since this strategy will ignore the row if there is a conflict." />
      <item value="IGNORE" />
      <item value="detect Moves" />
      <item value="new Item Statuses" />
      <item value="Convenience for Selection.extendSelection." />
      <item value="If non-null, this is the name of a previous back state to look for; if found, all states up to that state will be popped. The POP_BACK_STACK_INCLUSIVE flag can be used to control whether the named state itself is popped. If null, only the top state is popped." />
      <item value="returns the position of the y-labels" />
      <item value="If this is set to true, the y-axis is inverted which means that low values are on top of the chart, high values on bottom. Params: enabled –" />
      <item value="returns true if drawing the bottom y-axis label entry is enabled Returns:" />
      <item value="Request abbreviated scan results which contain the device, rssi and scan timestamp. Note: It is possible for an application to get more scan results than it asked for, if there are multiple apps using this type." />
      <item value="if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown." />
      <item value="if the value of millis is negative" />
      <item value="ReentrantLock" />
      <item value="Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call). Params: o – element to be removed from this queue, if present Returns: true if this queue changed as a result of the call" />
      <item value="Removes a node from head of queue. Returns: the node" />
      <item value="Condition" />
      <item value="lock Interruptibly" />
      <item value="Signals a waiting take. Called only from putoffer (which do not otherwise ordinarily lock takeLock.)" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs." />
      <item value="Wakes up one waiting thread. If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from await. Implementation Considerations An implementation may (and typically does) require that the current thread hold the lock associated with this Condition when this method is called. Implementations must document this precondition and any actions taken if the lock is not held. Typically, an exception such as IllegalMonitorStateException will be thrown." />
      <item value="signal" />
      <item value="get And Increment" />
      <item value="capacity" />
      <item value="Note that count is used in wait guard even though it is not protected by lock. This works because count can only decrease at this point (all other puts are shut out by lock), and we (or some other waiting put) are signalled if it ever changes from capacity. Similarly for all other uses of count in other wait guards." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2567" />
        <entry key="ENGLISH" value="2568" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657962795895" />
  </component>
</application>