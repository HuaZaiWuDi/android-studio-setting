<application>
  <component name="AppStorage">
    <histories>
      <item value="Error emitted when the connection to a specified device is already established or is being * established. In order to share the connection, share #establishConnection emissions." />
      <item value="PEER" />
      <item value="To prevent this exception from being emitted one must either:&lt;br&gt; * * always unsubscribe from the above mentioned Observable before subscribing again&lt;br&gt; * * {@link io.reactivex.Observable#share()} or {@link io.reactivex.Observable#publish()} the above mentioned * Observable so it will be subscribed only once" />
      <item value="Returns a new {@link ObservableSource} that multicasts (and shares a single subscription to) the original {@link ObservableSource}. As long as * there is at least one {@link Observer} this {@link ObservableSource} will be subscribed and emitting data. * When all subscribers have disposed it will dispose the source {@link ObservableSource}." />
      <item value="An exception being emitted from an {@link io.reactivex.Observable} returned by the function * {@link com.polidea.rxandroidble2.RxBleDevice#establishConnection(boolean)} or other establishConnection() overloads when this kind * of observable was already subscribed and {@link com.polidea.rxandroidble2.RxBleConnection} is currently being established or active." />
      <item value="A transformer which combines the {@code replay(1)}, {@code publish()}, and {@code refCount()} * operators." />
      <item value="Already connected to device with MAC address BC:E5:9F:48:96:D1" />
      <item value="TERMINATE" />
      <item value="Set how to log byte array values:" />
      <item value="Retry strategy allows retrying a long write operation. There are two supported scenarios: * - Once the failure happens you may re-emit the failure you've received, applying your own transformations like a delay or any other, * aiming to postpone the retry procedure. * - If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call * {@code onCompleted} or {@code onError} on the child subscription. The emission will be forwarded as an operation result." />
      <item value="a function that combines one item emitted by each of the source and collection ObservableSources and * returns an item to be emitted by the resulting ObservableSource" />
      <item value="Returns an Observable that emits the results of a specified function to the pair of values emitted by the * source ObservableSource and a specified collection ObservableSource." />
      <item value="so we zip three observables" />
      <item value="If any of the sources never produces an item but only terminates (normally or with an error), the * resulting sequence terminates immediately (normally or with all the errors accumulated till that point). * If that input source is also synchronous, other sources after it will not be subscribed to. *" />
      <item value="Combines two source ObservableSources by emitting an item that aggregates the latest values of each of the * source ObservableSources each time an item is received from either of the source ObservableSources, where this * aggregation is defined by a specified function." />
      <item value="previous batch of data was sent - we do not care if value emitted from the booleanObservable is TRUE or FALSE. But the value will be TRUE unless the previously sent data batch was the final one" />
      <item value="combine" />
      <item value="Lets assume that we do not know if the DC0 or DC1 will notify first. * It may also happen that Android OS will inform that the batch was transmitted after both DC0 and DC1 notify. *" />
      <item value="For the sake of this example lets assume that we have a Bluetooth Device that is retrieved by: *" />
      <item value="Setter for a retry strategy in case something goes wrong when writing data. If any {@link BleException} is raised, * a {@link WriteOperationRetryStrategy.LongWriteFailure} object is emitted. * {@link WriteOperationRetryStrategy.LongWriteFailure} contains both the {@link BleException} and the batch number * for which the write request failed. The {@link WriteOperationRetryStrategy.LongWriteFailure} emitted by the * writeOperationRetryStrategy will be used to retry the specified batch number write request." />
      <item value="the function that acknowledges writing of the batch of bytes. It takes * an {@link Observable} that emits a boolean value each time the byte array batch * has finished to write. {@link Boolean#TRUE} means that there are more items in the buffer, * {@link Boolean#FALSE} otherwise. If you want to delay the next batch use provided observable * and add some custom behavior (delay, waiting for a message from the device, etc.)" />
      <item value="Setter for a strategy used to mark batch write completed. Only after previous batch has finished, the next (if any left) can be * written. * If this is not specified - the next batch of bytes is written right after the previous one has finished. * * A bytes batch is a part (slice) of the original byte array to write. Imagine a byte array of {0, 1, 2, 3, 4} where the maximum * number of bytes that may be transmitted at once is 2. Then the original byte array will be transmitted in three batches: * {0, 1}, {2, 3}, {4} * * It is expected that the Observable returned from the writeOperationAckStrategy will emit exactly the same events as the source, * however you may delay them at your pace." />
      <item value="Auth" />
      <item value="Duplicate" />
      <item value="Blank" />
      <item value="SSL peer shut down incorrectly" />
      <item value="Bad escape character 'ygen'" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="24" />
        <entry key="ENGLISH" value="25" />
      </map>
    </option>
  </component>
</application>