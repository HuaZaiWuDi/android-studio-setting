<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="Called when a view created by this BaseItemProvider has been attached to a window. 当此BaseItemProvider出现在屏幕上的时候，会调用此方法" />
      <item value="command" />
      <item value="联动" />
      <item value="re" />
      <item value="Returns the adapter position of the first visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. (setReverseLayout(boolean)). Views are sorted by their positions in the adapter, not in the layout." />
      <item value="accept Partially Visible" />
      <item value="Find the topmost view under the given point. Params: x – Horizontal position in pixels to search y – Vertical position in pixels to search" />
      <item value="Lay out all relevant child views from the given adapter. The LayoutManager is in charge of the behavior of item animations. By default, RecyclerView has a non-null ItemAnimator, and simple item animations are enabled. This means that addremove operations on the adapter will result in animations to add new or appearing items, removed or disappearing items, and moved items. If a LayoutManager returns false from supportsPredictiveItemAnimations(), which is the default, and runs a normal layout operation during onLayoutChildren(RecyclerView.Recycler, RecyclerView.State), the RecyclerView will have enough information to run those animations in a simple way. For example, the default ItemAnimator, DefaultItemAnimator, will simply fade views in and out, whether they are actually addedremoved or whether they are moved on or off the screen due to other addremove operations. A LayoutManager wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the LayoutManager should return true from supportsPredictiveItemAnimations() and add additional logic to onLayoutChildren(RecyclerView.Recycler, RecyclerView.State). Supporting predictive animations means that onLayoutChildren(RecyclerView.Recycler, RecyclerView.State) will be called twice; once as a &quot;pre&quot; layout step to determine where items would have been prior to a real layout, and again to do the &quot;real&quot; layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, removed items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other views, including views that were not previously onscreen (referred to as APPEARING views), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed views. The second layout pass is the real layout in which only non-removed views will be used. The only additional requirement during this pass is, if supportsPredictiveItemAnimations() returns true, to note which views exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING views), and to positionlayout those views appropriately, without regard to the actual bounds of the RecyclerView. This allows the animation system to know the location to which to animate these disappearing views. The default LayoutManager implementations for RecyclerView handle all of these requirements for animations already. Clients of RecyclerView can either use one of these layout managers directly or look at their implementations of onLayoutChildren() to see how they account for the APPEARING and DISAPPEARING views." />
      <item value="Scroll to the specified adapter position with the given offset from resolved layout start. Resolved layout start depends on getReverseLayout(), ViewCompat.getLayoutDirection(View) and getStackFromEnd()." />
      <item value="Scroll the RecyclerView to make the position visible. RecyclerView will scroll the minimum amount that is necessary to make the target position visible. If you are looking for a similar behavior to android.widget.ListView.setSelection(int) or android.widget.ListView.setSelectionFromTop(int, int), use scrollToPositionWithOffset(int, int)." />
      <item value="compute Horizontal Scroll Range" />
      <item value="Returns the adapter position of the last fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges. Returns: The adapter position of the last fully visible view or RecyclerView.NO_POSITION if there aren't any visible items." />
      <item value="Returns the first child that is visible in the provided index range, i.e. either partially or fully visible depending on the arguments provided. Completely invisible children are not acceptable by this method, but could be returned using findOnePartiallyOrCompletelyInvisibleChild" />
      <item value="Offset the bounds of all child views by dy pixels. Useful for implementing simple scrolling in LayoutManagers." />
      <item value="Called when a view is attached to the RecyclerView. Params: view – The View which is attached to the RecyclerView" />
      <item value="This callback will also be called if visible item range changes after a layout calculation. In that case, dx and dy will be 0." />
      <item value="Callback method to be invoked when the RecyclerView has been scrolled. This will be called after the scroll has completed." />
      <item value="recyclerView – The RecyclerView which scrolled. dx – The amount of horizontal scroll. dy – The amount of vertical scroll." />
      <item value="find First Completely Visible Item Position" />
      <item value="Returns the number of children that are not hidden." />
      <item value="Find the topmost view under the given point. Params: x – Horizontal position in pixels to search y – Vertical position in pixels to search Returns: The child view under (x, y) or null if no matching child is found" />
      <item value="A callback interface that can be used to alter the drawing order of RecyclerView children. It works using the ViewGroup.getChildDrawingOrder(int, int) method, so any case that applies to that method also applies to this callback. For example, changing the drawing order of two views will not have any effect if their elevation values are different since elevation overrides the result of this callback." />
      <item value="Returns the index of the child to draw for this iteration. Override this if you want to change the drawing order of children. By default, it returns i." />
      <item value="on Request Disallow Intercept Touch Event" />
      <item value="An implementation of RecyclerView.OnItemTouchListener that has empty method bodies and default return values. You may prefer to extend this class if you don't need to override all methods. Another benefit of using this class is future compatibility. As the interface may change, we'll always provide a default implementation on this class so that your code won't break when you update to a new version of the support library." />
      <item value="This method is called whenever the view in the ViewHolder is recycled. RecyclerView calls this method right before clearing ViewHolder's internal data and sending it to RecycledViewPool. This way, if ViewHolder was holding valid information before being recycled, you can call RecyclerView.ViewHolder.getBindingAdapterPosition() to get its adapter position. Params: holder – The ViewHolder containing the view that was recycled" />
      <item value="The child view under (x, y) or null if no matching child is found" />
      <item value="Find the topmost view under the given point." />
      <item value="Returns true if the RecyclerView is in the pre-layout step where it is having its RecyclerView.LayoutManager layout items where they will be at the beginning of a set of predictive item animations." />
      <item value="Views that did not measure the maxSize has to be re-measured We will stop doing this once we introduce Gravity in the GLM layout params" />
      <item value="ensure Anchor Is In Correct Span" />
      <item value="色温" />
      <item value="se'ewn" />
      <item value="Strict Mode" />
      <item value="Thread Policy" />
      <item value="StrictMode ThreadPolicy violation" />
      <item value="Writes resources to disk after they've been decoded." />
      <item value="Writes retrieved data directly to the disk cache before it's decoded." />
      <item value="Received invalid resource id: 0" />
      <item value="eturns a mutable bitmap with the specified width and height. Its initial density is as per getDensity. The newly created bitmap is in the sRGB color space. Params:" />
      <item value="Bitmaps in the pool contain random data that in some cases must be cleared for an image to be rendered correctly. we shouldn't force all consumers to independently erase the contents individually, so we do so here. See issue 131." />
      <item value="An interface for a pool that allows users to reuse Bitmap objects." />
      <item value="Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over when cached data is invalidated. Note - The signature does not replace the cache key, it is purely additive. Params: signature – A unique non-null Key representing the current state of the model that will be mixed in to the cache key. Returns: This request builder." />
      <item value="Caches remote data with both DATA and RESOURCE, and local data with RESOURCE only." />
      <item value="Tries to intelligently choose a strategy based on the data source of the com.bumptech.glide.load.data.DataFetcher and the EncodeStrategy of the com.bumptech.glide.load.ResourceEncoder (if an com.bumptech.glide.load.ResourceEncoder is available)." />
      <item value="The drawer is locked open. The user may not close it, though the app may close it programmatically." />
      <item value="The drawer is locked closed. The user may not open it, though the app may open it programmatically." />
      <item value="Returns: The horizontal offset of the scrollbar's thumb" />
      <item value="If you want to support scroll bars, override RecyclerView.LayoutManager.computeHorizontalScrollOffset(RecyclerView.State) in your LayoutManager." />
      <item value="Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by computeHorizontalScrollRange() and computeHorizontalScrollExtent()." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2273" />
        <entry key="ENGLISH" value="2273" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1655091842203" />
  </component>
</application>