<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="m Drawing Cache" />
      <item value="Indicates the activation state of this view. Returns: true if the view is activated, false otherwise" />
      <item value="If this object has changed, as indicated by the hasChanged method, then notify all of its observers and then call the clearChanged method to indicate that this object has no longer changed. Each observer has its update method called with two arguments: this observable object and null. In other words, this method is equivalent to: notifyObservers(null)" />
      <item value="Marks this Observable object as having been changed; the hasChanged method will now return true." />
      <item value="Tests if this object has changed. Returns: true if and only if the setChanged method has been called more recently than the clearChanged method on this object; false otherwise. See Also: clearChanged(), setChanged()" />
      <item value="This method is called whenever the observed object is changed. An application calls an Observable object's notifyObservers method to have all the object's observers notified of the change. Params: o – the observable object. arg – an argument passed to the notifyObservers method." />
      <item value="Observable" />
      <item value="If this object has changed, as indicated by the &lt;code&gt;hasChanged&lt;code&gt; method, then notify all of its observers and then call the &lt;code&gt;clearChanged&lt;code&gt; method to indicate that this object has no longer changed. &lt;p&gt; Each observer has its &lt;code&gt;update&lt;code&gt; method called with two arguments: this observable object and &lt;code&gt;null&lt;code&gt;. In other words, this method is equivalent to:" />
      <item value="We don't want the Observer doing callbacks into arbitrary code while holding its own Monitor. The code where we extract each Observable from the Vector and store the state of the Observer needs synchronization, but notifying observers does not (should not). The worst result of any potential race-condition here is that: 1) a newly-added Observer will miss a notification in progress 2) a recently unregistered Observer will be wrongly notified when it doesn't care Android-changed: Call out to hasChanged() to figure out if something changes. Upstream code avoids calling the nonfinal hasChanged() from the synchronized block, but that would break compatibility for apps that override that method. if (!changed)" />
      <item value="This class represents an observable object, or &quot;data&quot; in the model-view paradigm. It can be subclassed to represent an object that the application wants to have observed. An observable object can have one or more observers. An observer may be any object that implements interface Observer. After an observable instance changes, an application calling the Observable's notifyObservers method causes all of its observers to be notified of the change by a call to their update method. The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose. Note that this notification mechanism has nothing to do with threads and is completely separate from the wait and notify mechanism of class Object. When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the equals method returns true for them. Since: JDK1.0 See Also: notifyObservers(), notifyObservers(Object), Observer, Observer.update(Observable, Object) Author: Chris Warth" />
      <item value="This method is called whenever the observed object is changed. An application calls an Observable object's notifyObservers method to have all the object's observers notified of the change." />
      <item value="RecyclerView calls this method right before clearing ViewHolder's internal data and sending it to RecycledViewPool. This way, if ViewHolder was holding valid information before being recycled, you can call RecyclerView.ViewHolder.getBindingAdapterPosition() to get its adapter position." />
      <item value="A view is recycled when a RecyclerView.LayoutManager decides that it no longer needs to be attached to its parent RecyclerView. This can be because it has fallen out of visibility or a set of cached views represented by views still attached to the parent RecyclerView. If an item view has large or expensive data bound to it such as large bitmaps, this may be a good place to release those resources. RecyclerView calls this method right before clearing ViewHolder's internal data and sending it to RecycledViewPool. This way, if ViewHolder was holding valid information before being recycled, you can call RecyclerView.ViewHolder.getBindingAdapterPosition() to get its adapter position." />
      <item value="Called when a view created by this adapter has been recycled." />
      <item value="The provider that owns this Lifecycle. Only WeakReference on LifecycleOwner is kept, so if somebody leaks Lifecycle, they won't leak the whole Fragment Activity. However, to leak Lifecycle object isn't great idea neither, because it keeps strong references on all other listeners, so you'll leak all of them as well." />
      <item value="m New Event Occurred" />
      <item value="backward Pass" />
      <item value="newest" />
      <item value="ceil" />
      <item value="delta" />
      <item value="remaining Space" />
      <item value="More optimized set the click listener inside the view holder" />
      <item value="TODO: Consider the case mFlexWrap is set to nowrap and view is recycled individually" />
      <item value="Echelon" />
      <item value="Skid Right" />
      <item value="Stack" />
      <item value="Contains the calculateExtraLayoutSpace(RecyclerView.State, int[]) extra layout space} that should be excluded for recycling when cleaning up the tail of the list during a smooth scroll." />
      <item value="m No Recycle Space" />
      <item value="get Transformed Start With Decoration" />
      <item value="Recycles views that went out of bounds after scrolling towards the start of the layout. Checks both layout position and visible position to guarantee that the view is not visible." />
      <item value="ecycles views that went out of bounds after scrolling towards the start of the layout. Checks both layout position and visible position to guarantee that the view is not visible." />
      <item value="Current layout state. Right now, this object does not change but we may consider moving it out of this view so passing around as a parameter for now, rather than accessing mLayoutState" />
      <item value="Helper method to call appropriate recycle method depending on current layout direction Params: recycler – Current recycler that is attached to RecyclerView layoutState – Current layout state. Right now, this object does not change but we may consider moving it out of this view so passing around as a parameter for now, rather than accessing mLayoutState" />
      <item value="amount" />
      <item value="Decorated" />
      <item value="Helper class for LayoutManagers to abstract measurements depending on the View's orientation. It is developed to easily support vertical and horizontal orientations in a LayoutManager but can also be used to abstract calls around view bounds and child measurements with margins and decorations. See Also: createHorizontalHelper(RecyclerView.LayoutManager), createVerticalHelper(RecyclerView.LayoutManager)" />
      <item value="Payload info. if return null, the entire item will be refreshed." />
      <item value="When areItemsTheSame(T, T) returns true for two items and areContentsTheSame(T, T) returns false for them, this method is called to get a payload about the change. For example, if you are using DiffUtil with RecyclerView, you can return the particular field that changed in the item and your ItemAnimator can use that information to run the correct animation." />
      <item value="Called by the DiffUtil when it wants to check whether two items have the same data. DiffUtil uses this information to detect if the contents of an item has changed. DiffUtil uses this method to check equality instead of Object.equals(Object) so that you can change its behavior depending on your UI. For example, if you are using DiffUtil with a RecyclerView.Adapter, you should return whether the items' visual representations are the same." />
      <item value="True if the contents of the items are the same or false if they are different." />
      <item value="oldItem – The item in the old list. newItem – The item in the new list." />
      <item value="Called to check whether two items have the same data. This information is used to detect if the contents of an item have changed. This method to check equality instead of Object.equals(Object) so that you can change its behavior depending on your UI. For example, if you are using DiffUtil with a RecyclerView.Adapter, you should return whether the items' visual representations are the same. This method is called only if areItemsTheSame(T, T) returns true for these items. Note: Two null items are assumed to represent the same contents. This callback will not be invoked for this case." />
      <item value="Temporarily detach and scrap all currently attached child views. Views will be scrapped into the given Recycler. The Recycler may prefer to reuse scrap views before other views that were previously recycled. Params: recycler – Recycler to scrap views into" />
      <item value="detach And Scrap Attached Views(recycler);" />
      <item value="Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch any more events. For instance, for an android.app.Activity, this state is reached right before Activity's onDestroy call." />
      <item value="Modifies the source Publisher so that it invokes the given action when it is subscribed from its subscribers. Each subscription will result in an invocation of the given action except when the source Publisher is reference counted, in which case the source Publisher will invoke the given action for the first subscription." />
      <item value="Modifies the source Publisher so that it invokes the given action when it receives a request for more items. Note: This operator is for tracing the internal behavior of back-pressure request patterns and generally intended for debugging use." />
      <item value="No Op" />
      <item value="Attempts to get the ViewHolder for the given position, either from the Recycler scrap, cache, the RecycledViewPool, or creating it directly." />
      <item value="position – Position of ViewHolder to be returned. dryRun – True if the ViewHolder should not be removed from scrapcache deadlineNs – Time, relative to getNanoTime(), by which bindcreate work should complete. If FOREVER_NS is passed, this method will not fail to createbind the holder if needed." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2480" />
        <entry key="ENGLISH" value="2481" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="11" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SPANISH" value="3" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1657530776017" />
  </component>
</application>