<application>
  <component name="AppStorage">
    <histories>
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX." />
      <item value="Portrait" />
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics. * * &lt;p&gt;Multiple filters can be added. All filters will be applied by the order they were * added when the {@link CameraSelector} is used, and the first camera output from the * filters will be selected." />
      <item value="A {@link Future} that accepts completion listeners. Each listener has an associated executor, and * it is invoked using this executor once the future's computation is {@linkplain Future#isDone() * complete}. If the computation has already completed when the listener is added, the listener will * execute immediately. *" />
      <item value="&lt;p&gt;When the producer stops producing images, it may also stop producing images for other use cases, such as {@link Preview}, so it is important for the analyzer to keep up with frame rate, &lt;i&gt;on average&lt;/i&gt;. Failure to keep up with frame rate may lead to jank in the frame stream and a diminished user experience. If more time is needed for analysis on &lt;i&gt;some&lt;/i&gt; frames, consider increasing the image queue depth with {@link Builder#setImageQueueDepth(int)}." />
      <item value="&lt;p&gt;Once the producer has produced the number of images equal to the image queue depth, and none have been closed, the producer will stop producing images. Note that images may be queued internally and not be delivered to the analyzer until the last delivered image has been closed with {@link ImageProxy#close()}. These internally queued images will count towards the total number of images that the producer can provide at any one time." />
      <item value="&lt;p&gt;This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. Only one image will be delivered for analysis at a time. If more images are produced while that image is being analyzed, they will be dropped and not queued for delivery. Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the next latest image will be delivered." />
      <item value="Block the producer from generating new images." />
      <item value="PRODUCER" />
      <item value="&gt;The available values are {@link #STRATEGY_BLOCK_PRODUCER} and * {@link #STRATEGY_KEEP_ONLY_LATEST}. * * &lt;p&gt;If not set, the backpressure strategy will default to * {@link #STRATEGY_KEEP_ONLY_LATEST}. *" />
      <item value="This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. * Only one image will be delivered for analysis at a time. If more images are produced * while that image is being analyzed, they will be dropped and not queued for delivery. * Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the * next latest image will be delivered." />
      <item value="Only deliver the latest image to the analyzer, dropping images as they arrive" />
      <item value="Once the producer has produced the number of images equal to the image queue depth, * and none have been closed, the producer will stop producing images. Note that images * may be queued internally and not be delivered to the analyzer until the last delivered * image has been closed with {@link ImageProxy#close()}. These internally queued images * will count towards the total number of images that the producer can provide at any one * time." />
      <item value="The requested capture processor for extension." />
      <item value="Processor" />
      <item value="Turn on the local Bluetooth adapter&amp;mdash;do not use without explicit user action to turn on Bluetooth. &lt;p&gt;This powers on the underlying Bluetooth hardware, and starts all Bluetooth system services. &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Bluetooth should never be enabled without direct user consent&lt;/strong&gt;. If you want to turn on Bluetooth in order to create a wireless connection, you should use the {@link #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests user permission to turn on Bluetooth. The {@link #enable()} method is provided only for applications that include a user interface for changing system settings, such as a &quot;power manager&quot; app.&lt;/p&gt; &lt;p&gt;This is an asynchronous call: it will return immediately, and clients should listen for {@link #ACTION_STATE_CHANGED} to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from {@link #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time later transition to either {@link #STATE_OFF} or {@link #STATE_ON}. If this call returns false then there was an immediate problem that will prevent the adapter from being turned on - such as Airplane mode, or the adapter is already turned on." />
      <item value="Turn on the local Bluetooth adapter&amp;mdash;do not use without explicit * user action to turn on Bluetooth." />
      <item value="rationale" />
      <item value="Some privileges permanently disabled, may need to set up in the execute." />
      <item value="Handle overlay permission." />
      <item value="不支持" />
      <item value="Do your init work in this method, it well be call when processor has been load." />
      <item value="ethernet" />
      <item value="pool" />
      <item value="This shouldn't ever happen, see #331." />
      <item value="dump" />
      <item value="A strategy for reusing bitmaps that requires any returned bitmap's dimensions to exactly match * those request." />
      <item value="Cloud" />
      <item value="Returns the value mapped by {@code name} if it exists and is a {@code * JSONObject}, or null otherwise." />
      <item value="at result of type java.lang.String cannot be converted to JSONObject" />
      <item value="Sets a Disposable on this emitter; any previous Disposable * or Cancellable will be disposed/cancelled." />
      <item value="A functional interface that has a single cancel method * that can throw." />
      <item value="Sets a Cancellable on this emitter; any previous {@link Disposable} * or {@link Cancellable} will be disposed/cancelled." />
      <item value="the emitter that is called when a SingleObserver subscribes to the returned {@code Single}" />
      <item value="Provides an API (via a cold Completable) that bridges the reactive world with the callback-style world." />
      <item value="Read error: ssl=0xc8d77828: I/O error during system call, Software caused connection abort" />
      <item value="refresh Wifi List" />
      <item value="Movement" />
      <item value="不允许绑定" />
      <item value="重新绑定" />
      <item value="已绑定" />
      <item value="binded" />
      <item value="unregister" />
      <item value="cloud" />
      <item value="cloudcloud" />
      <item value="生成" />
      <item value="UNSUPPORT" />
      <item value="transport" />
      <item value="传输" />
      <item value="PARAMETER" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1535" />
        <entry key="ENGLISH" value="1536" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>