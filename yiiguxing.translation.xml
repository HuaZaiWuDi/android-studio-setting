<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="373" />
    <option name="newTranslationDialogX" value="572" />
    <option name="newTranslationDialogY" value="129" />
    <histories>
      <item value="Flash Mode" />
      <item value="A set of requirements and priorities used to select a camera or return a filtered set of cameras." />
      <item value="RejectedExecutionException at discretion of {@code RejectedExecutionHandler}, if the task cannot be accepted for execution" />
      <item value="Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads." />
      <item value="When set on a View, this listener method will be called instead of the view's own onApplyWindowInsets method." />
      <item value="Called when a new child is added to this ViewGroup. Overrides should always call super.onViewAdded." />
      <item value="Transforms a passed value to a LSB first byte array with the size of the specified capacity Params: capacity – size of the resulting byte array value – that should be represented as a byte array" />
      <item value="español" />
      <item value="captcha" />
      <item value="Register a listener that will be notified whenever a child view is attached to or detached from RecyclerView. This listener will be called when a LayoutManager or the RecyclerView decides that a child view is no longer needed. If an application associates expensive or heavyweight data with item views, this may be a good place to release or free those resources. Params: listener – Listener to register" />
      <item value="Pattern Run" />
      <item value="&lt;p&gt;The resulting {@link android.view.ViewStructure} is then passed to the autofill service, which parses it looking for views that can be autofilled. If the service finds such views, it returns a data structure to the Android System containing the following optional info: &lt;ul&gt; &lt;li&gt;Datasets used to autofill subsets of views in the activity. &lt;li&gt;Id of views that the service can save their values for future autofilling. &lt;ul&gt; &lt;p&gt;When the service returns datasets, the Android System displays an autofill dataset picker UI associated with the view, when the view is focused on and is part of a dataset. The application can be notified when the UI is shown by registering an {@link AutofillCallback} through {@link registerCallback(AutofillCallback)}. When the user selects a dataset from the UI, all views present in the dataset are autofilled, through calls to {@link Viewautofill(AutofillValue)} or {@link Viewautofill(SparseArray)}. &lt;p&gt;When the service returns ids of savable views, the Android System keeps track of changes made to these views, so they can be used to determine if the autofill save UI is shown later. &lt;p&gt;The context is then finished when one of the following occurs: &lt;ul&gt; &lt;li&gt;{@link commit()} is called or all savable views are gone. &lt;li&gt;{@link cancel()} is called. &lt;ul&gt; &lt;p&gt;Finally, after the autofill context is commited (i.e., not cancelled), the Android System shows an autofill save UI if the value of savable views have changed. If the user selects the option to Save, the current value of the views is then sent to the autofill service. &lt;h3 id=&quot;additional-notes&quot;&gt;Additional notes&lt;h3&gt; &lt;p&gt;It is safe to call &lt;code&gt;AutofillManager&lt;code&gt; methods from any thread." />
      <item value="&lt;p&gt;Typically, the context is automatically created when the first view of the activity is focused because {@code View.onFocusChanged()} indirectly calls {@link notifyViewEntered(View)}. App developers can call {@link requestAutofill(View)} to explicitly create it (for example, a custom view developer could offer a contextual menu action in a text-field view to let users manually request autofill). &lt;p&gt;After the context is created, the Android System creates a {@link android.view.ViewStructure} that represents the view hierarchy by calling {@link ViewdispatchProvideAutofillStructure(android.view.ViewStructure, int)} in the root views of all application windows. By default, {@code dispatchProvideAutofillStructure()} results in subsequent calls to {@link ViewonProvideAutofillStructure(android.view.ViewStructure, int)} and {@link ViewonProvideAutofillVirtualStructure(android.view.ViewStructure, int)} for each view in the hierarchy. &lt;p&gt;The resulting {@link android.view.ViewStructure} is then passed to the autofill service, which parses it looking for views that can be autofilled. If the service finds such views, it returns a data structure to the Android System containing the following optional info:" />
      <item value="&lt;p&gt;The {@link AutofillManager} class provides ways for apps and custom views to integrate with the Autofill Framework lifecycle. &lt;p&gt;To learn about using Autofill in your app, read the &lt;a href=&quot;guidetopicstextautofill&quot;&gt;Autofill Framework&lt;a&gt; guides. &lt;h3 id=&quot;autofill-lifecycle&quot;&gt;Autofill lifecycle&lt;h3&gt; &lt;p&gt;The autofill lifecycle starts with the creation of an autofill context associated with an activity context. The autofill context is created when one of the following methods is called for the first time in an activity context, and the current user has an enabled autofill service: &lt;ul&gt; &lt;li&gt;{@link notifyViewEntered(View)} &lt;li&gt;{@link notifyViewEntered(View, int, Rect)} &lt;li&gt;{@link requestAutofill(View)} &lt;ul&gt; &lt;p&gt;Typically, the context is automatically created when the first view of the activity is focused because {@code View.onFocusChanged()} indirectly calls {@link notifyViewEntered(View)}. App developers can call {@link requestAutofill(View)} to explicitly create it (for example, a custom view developer could offer a contextual menu action in a text-field view to let users manually request autofill). &lt;p&gt;After the context is created, the Android System creates a {@link android.view.ViewStructure} that represents the view hierarchy by calling {@link ViewdispatchProvideAutofillStructure(android.view.ViewStructure, int)} in the root views of all application windows. By default, {@code dispatchProvideAutofillStructure()} results in subsequent calls to {@link ViewonProvideAutofillStructure(android.view.ViewStructure, int)} and {@link ViewonProvideAutofillVirtualStructure(android.view.ViewStructure, int)} for each view in the hierarchy. &lt;p&gt;The resulting {@link android.view.ViewStructure} is then passed to the autofill service, which parses it looking for views that can be autofilled. If the service finds such views, it returns a data structure to the Android System containing the following optional info: &lt;ul&gt; &lt;li&gt;Datasets used to autofill subsets of views in the activity. &lt;li&gt;Id of views that the service can save their values for future autofilling. &lt;ul&gt; &lt;p&gt;When the service returns datasets, the Android System displays an autofill dataset picker UI associated with the view, when the view is focused on and is part of a dataset. The application can be notified when the UI is shown by registering an {@link AutofillCallback} through {@link registerCallback(AutofillCallback)}. When the user selects a dataset from the UI, all views present in the dataset are autofilled, through calls to {@link Viewautofill(AutofillValue)} or {@link Viewautofill(SparseArray)}. &lt;p&gt;When the service returns ids of savable views, the Android System keeps track of changes made to these views, so they can be used to determine if the autofill save UI is shown later. &lt;p&gt;The context is then finished when one of the following occurs: &lt;ul&gt; &lt;li&gt;{@link commit()} is called or all savable views are gone. &lt;li&gt;{@link cancel()} is called. &lt;ul&gt; &lt;p&gt;Finally, after the autofill context is commited (i.e., not cancelled), the Android System shows an autofill save UI if the value of savable views have changed. If the user selects the option to Save, the current value of the views is then sent to the autofill service. &lt;h3 id=&quot;additional-notes&quot;&gt;Additional notes&lt;h3&gt; &lt;p&gt;It is safe to call &lt;code&gt;AutofillManager&lt;code&gt; methods from any thread." />
      <item value="Returns true if the calling application provides a AutofillService that is enabled for the current user, or false otherwise." />
      <item value="Called to indicate the current autofill context should be cancelled. This method is typically called by Views that manage virtual views; for example, when the view is rendering an HTML page with a form and virtual views that represent the HTML elements, it should call this method if the user does not post the form but moves to another form in this page. Note: This method does not need to be called on regular application lifecycle methods such as android.app.Activity.finish()." />
      <item value="If not explicitly specified, this view and its children don't support autofill. &lt;p&gt; This is done because autofill's means of uniquely identifying views doesn't work out of the box with View recycling." />
      <item value="Accessing hidden field LandroidappActivity;-&gt;mAutoFillResetNeeded:Z (greylist-max-o, reflection, denied)" />
      <item value="Sets the mode for determining whether this view is considered important for autofill. The platform determines the importance for autofill automatically but you can use this method to customize the behavior. For example: When the view contents is irrelevant for autofill (for example, a text field used in a &quot;Captcha&quot; challenge), it should be View.IMPORTANT_FOR_AUTOFILL_NO. When both the view and its children are irrelevant for autofill (for example, the root view of an activity containing a spreadhseet editor), it should be View.IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS. When the view content is relevant for autofill but its children aren't (for example, a credit card expiration date represented by a custom view that overrides the proper autofill methods and has 2 children representing the month and year), it should be View.IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS. NOTE: setting the mode as does View.IMPORTANT_FOR_AUTOFILL_NO or View.IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS does not guarantee the view (and its children) will be always be considered not important; for example, when the user explicitly makes an autofill request, all views are considered important. See isImportantForAutofill(View) for more details about how the View's importance for autofill is used." />
      <item value="Returns true if autofill is supported by the current device and is supported for this user. Autofill is typically supported, but it could be unsupported in cases like: Low-end devices. Device policy rules that forbid its usage." />
      <item value="Called by android.app.Activity to commit or cancel the session on finish." />
      <item value="Explicitly requests a new autofill context. Normally, the autofill context is automatically started if necessary when notifyViewEntered(View) is called, but this method should be used in the cases where it must be explicitly started. For example, when the view offers an AUTOFILL option on its contextual overflow menu, and the user selects it. Params: view – view requesting the new autofill context." />
      <item value="whether the view is considered important for autofill." />
      <item value="Sets the hints that help an android.service.autofill.AutofillService determine how to autofill the view with the user's data." />
      <item value="Hint the Android System that this view is not important for autofill, but its children (if any) will be traversed.." />
      <item value="Hint the Android System that this view is important for autofill, and its children (if any) will be traversed.." />
      <item value="Let the Android System use its heuristics to determine if the view is important for autofill." />
      <item value="Hints the Android System whether the view node associated with this View should be included in a view structure used for autofill purposes." />
      <item value="Declare AutofillService implementation; only needed for a small number of apps that will be implementing an AutofillService. Framework parses meta-data and sets the service's Settings Activity based on what the meta-data resource points to." />
      <item value="Called to indicate the current autofill context should be commited. This method is typically called by Views that manage virtual views; for example, when the view is rendering an HTML page with a form and virtual views that represent the HTML elements, it should call this method after the form is submitted and another page is rendered. Note: This method does not need to be called on regular application lifecycle methods such as android.app.Activity.finish()." />
      <item value="Hint the Android System that this view is important for autofill, but its children (if any) will not be traversed." />
      <item value="Hint the Android System that this view is not important for autofill, and its children (if any) will not be traversed." />
      <item value="DROP" />
      <item value="RecyclerView listens for Adapter's notify events and calculates the effects of adapter data changes on existing Views. These calculations are used to decide which animations should be run. To support predictive animations, RecyclerView may rewrite or reorder Adapter changes to present the correct state to LayoutManager in pre-layout pass. For example, a newly added item is not included in pre-layout item count because pre-layout reflects the contents of the adapter before the item is added. Behind the scenes, RecyclerView offsets RecyclerView.Recycler.getViewForPosition(int) calls such that LayoutManager does not know about the new item's existence in pre-layout. The item will be available in second layout pass and will be included in the item count. Similar adjustments are made for moved and removed items as well." />
      <item value="Returns the total number of items that can be laid out. Note that this number is not necessarily equal to the number of items in the adapter, so you should always use this number for your position calculations and never access the adapter directly." />
      <item value="get Column Count For Accessibility" />
      <item value="Row count is one more than the last item's row index." />
      <item value="Returns true if Glide should check the AndroidManifest for GlideModules. Implementations should return false after they and their dependencies have migrated to Glide's annotation processor. Returns true by default." />
      <item value="Defines a set of dependencies and options to use when initializing Glide within an application. There can be at most one AppGlideModule in an application. Only Applications can include a AppGlideModule. Libraries must use LibraryGlideModule. Classes that extend AppGlideModule must be annotated with com.bumptech.glide.annotation.GlideModule to be processed correctly. Classes that extend AppGlideModule can optionally be annotated with com.bumptech.glide.annotation.Excludes to optionally exclude one or more LibraryGlideModule andor GlideModule classes. Once an application has migrated itself and all libraries it depends on to use Glide's annotation processor, AppGlideModule implementations should override isManifestParsingEnabled() and return false." />
      <item value="incrementing generation means any currently-running diffs are discarded when they finish" />
      <item value="Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional types" />
      <item value="Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional type" />
      <item value="marquee" />
      <item value="Hide the dialog, but do not dismiss it." />
      <item value="Returns drawables for the start, top, end, and bottom borders." />
      <item value="icon gravity view" />
      <item value="m Icon GRAVITY" />
      <item value="Add a listener for attach state changes. This listener will be called whenever this view is attached or detached from a window. Remove the listener using removeOnAttachStateChangeListener(View.OnAttachStateChangeListener)." />
      <item value="Check whether a particular package has been granted a particular permission. Params: permName – The name of the permission you are checking for. packageName – The name of the package you are checking against. Returns: If the package has the permission, PERMISSION_GRANTED is returned. If it does not have the permission, PERMISSION_DENIED is returned." />
      <item value="true to indicate adapter startup has begun, or false on immediate error" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="3209" />
        <entry key="ENGLISH" value="3221" />
        <entry key="CHINESE_TRADITIONAL" value="6" />
        <entry key="BASQUE" value="1" />
        <entry key="GERMAN" value="5" />
        <entry key="RUSSIAN" value="6" />
        <entry key="FRENCH" value="6" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="KOREAN" value="13" />
        <entry key="DUTCH" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="LATIN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="ESPERANTO" value="27" />
        <entry key="SPANISH" value="9" />
        <entry key="ITALIAN" value="6" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1671071274421" />
  </component>
  <component name="Settings">
    <option name="showExplanation" value="true" />
    <option name="showWordsOnStartup" value="true" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1695627934099" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
    <option name="translator" value="MICROSOFT" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogHeight" value="251" />
    <option name="newTranslationDialogX" value="848" />
    <option name="newTranslationDialogY" value="216" />
    <histories>
      <item value="None of the following functions can be called with the arguments supplied:" />
      <item value="auto Size Preset Sizes" />
      <item value="SecurityException – If the caller does not have permission to access the service or the service can not be found. ForegroundServiceStartNotAllowedException – If the caller app's targeting API is Build.VERSION_CODES.S or later, and the foreground service is restricted from start due to background restriction." />
      <item value="Similar to startService(Intent), but with an implicit promise that the Service will call startForeground(int, android.app.Notification) once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically crash the process, in which case an internal exception ForegroundServiceDidNotStartInTimeException is logged on logcat on devices running SDK Version Build.VERSION_CODES.S or later. On older Android versions, an internal exception RemoteServiceException is logged instead, with a corresponding message. Unlike the ordinary startService(Intent), this method can be used at any time, regardless of whether the app hosting the service is in a foreground state. Note: Beginning with SDK Version Build.VERSION_CODES.S, apps targeting SDK Version Build.VERSION_CODES.S or higher are not allowed to start foreground services from the background. See Behavior changes: Apps targeting Android 12 for more details. Params: service – Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call. Returns: If the service is being started or is already running, the ComponentName of the actual service that was started is returned; else if the service does not exist null is returned. Throws: SecurityException – If the caller does not have permission to access the service or the service can not be found. ForegroundServiceStartNotAllowedException – If the caller app's targeting API is Build.VERSION_CODES.S or later, and the foreground service is restricted from start due to background restriction." />
      <item value="TransferService is limited to the following functionality: Registers a listener with Android OS for network connectivity changes. When network goes offline, the active transfers are paused. When network come back online, the paused transfers are resumed. This works both in foreground as well as background." />
      <item value="if param foregroundServiceType is not subset of manifest attribute android.R.attr.foregroundServiceType." />
      <item value="Similar to startService(Intent), but with an implicit promise that the Service will call startForeground(int, android.app.Notification) once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically crash the process, in which case an internal exception" />
      <item value="Similar to startService(Intent), but with an implicit promise that the Service will call startForeground(int, android.app.Notification) once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically crash the process, in which case an internal exception ForegroundServiceDidNotStartInTimeException is logged on logcat on devices running SDK Version Build.VERSION_CODES.S or later. On older Android versions, an internal exception RemoteServiceException is logged instead, with a corresponding message. Unlike the ordinary startService(Intent), this method can be used at any time, regardless of whether the app hosting the service is in a foreground state. Note: Beginning with SDK Version Build.VERSION_CODES.S, apps targeting SDK Version Build.VERSION_CODES.S or higher are not allowed to start foreground services from the background. See Behavior changes: Apps targeting Android 12 for more details. Params: service – Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call. Returns: If the service is being started or is already running, the ComponentName of the actual service that was started is returned; else if the service does not exist null is returned. Throws: SecurityException – If the caller does not have permission to access the service or the service can not be found. ForegroundServiceStartNotAllowedException – If the caller app's targeting API is Build.VERSION_CODES.S or later, and the foreground service is restricted from start due to background restriction. See Also: stopService, android.app.Service.startForeground(int, android.app.Notification)" />
      <item value="Sets a one-time callback that will be notified when the value of the given characteristic changes. This is a blocking request, so the next request will be executed after the notification was received. If WaitForValueChangedRequest.merge(DataMerger) was used, the whole message will be completed before the callback is notified." />
      <item value="Sets a one-time callback that will be notified when the value of the given descriptor changes. This is a blocking request, so the next request will be executed after the write command or write request was received." />
      <item value="The condition to examine. If it's not satisfied, the manager will wait." />
      <item value="Creates a conditional wait request that will wait until the given condition is not satisfied. The condition is checked when the request is executed and each time a new BLE operation is complet" />
      <item value="the data to be sent as read response." />
      <item value="The returned request must be either enqueued using Request.enqueue() for asynchronous use, or awaited using await() in synchronous execution." />
      <item value="Sets the given data to the readable server characteristic and waits until they are read by the remote device." />
      <item value="Sets the given data to the readable server descriptor and waits until they are read by the remote device. The returned request must be either enqueued using Request.enqueue() for asynchronous use, or awaited using await() in synchronous execution." />
      <item value="and you want some of them to be executed together." />
      <item value="Creates an atomic request queue. The requests from the queue will be executed in order. This is useful when more then one thread may add requests and you want some of them to be executed together." />
      <item value="Begins the Reliable Write sub-procedure. Requests that need to be performed reliably should be enqueued with ReliableWriteRequest.add(Operation) instead of using Request.enqueue(). The library will verify all Write operations and will automatically abort the Reliable Write procedure when the returned data mismatch with the data sent. When all requests enqueued in the ReliableWriteRequest were completed, the Reliable Write will be automatically executed. Long Write will not work when Reliable Write is in progress. The library will make sure that WriteRequest.split() was called for all WriteRequest packets, had they not been assigned other splitter. At least one Write operation must be executed before executing or aborting, otherwise the GattError.GATT_INVALID_OFFSET error will be reported. Because of that, enqueueing a ReliableWriteRequest without any operations does nothing." />
      <item value="This flag is set to false only when the ConnectRequest.shouldAutoConnect() method returns true and the device got disconnected without calling BleManager.disconnect() method. If ConnectRequest.shouldAutoConnect() returns false (default) this is always set to true." />
      <item value="ctivity Action: Show settings to manage installed applications. In some cases, a matching Activity may not exist, so ensure you safeguard against this." />
      <item value="Provide original WindowInsetsCompat that are dispatched to the view hierarchy. The insets are only available if the view is attached. On devices running API 20 and below, this method always returns null. Returns: WindowInsetsCompat from the top of the view hierarchy or null if View is detached" />
      <item value="Provide original WindowInsetsCompat that are dispatched to the view hierarchy. The insets are only available if the view is attached." />
      <item value="Set normal transition anim" />
      <item value="This method is called to notify you that, within s, the count characters beginning at start have just replaced old text that had length before. It is an error to attempt to make changes to s from this callback." />
      <item value="Called attach on a child which is not detached" />
      <item value="tmpDetached no parent" />
      <item value="Inconsistency detected" />
      <item value="handle" />
      <item value="guide Complete" />
      <item value="Returns a Single that emits only the last item emitted by this Flowable or signals a NoSuchElementException if this Flowable is empty." />
      <item value="Processing" />
      <item value="使用教程" />
      <item value="使用jioa'c" />
      <item value="stack corruption detected" />
      <item value="One of the TOUCH_SLOP_ constants representing the intended usage of this RecyclerView" />
      <item value="Slop" />
      <item value="set Scrolling Touch Slop" />
      <item value="Configure the scrolling touch slop for a specific use case. Set up the RecyclerView's scrolling motion threshold based on common usages. Valid arguments are TOUCH_SLOP_DEFAULT and TOUCH_SLOP_PAGING." />
      <item value="Returns the adapter position of the last visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. (setReverseLayout(boolean)). Views are sorted by their positions in the adapter, not in the layout. If RecyclerView has item decorators, they will be considered in calculations as well. LayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method." />
      <item value="The amount of vertical scroll." />
      <item value="Resumed state for a LifecycleOwner. For an android.app.Activity, this state is reached after onResume is called." />
      <item value="Change the view's z order in the tree, so it's on top of other sibling views. This ordering change may affect layout," />
      <item value="Español" />
      <item value="Present the text in ALL CAPS. This may use a small-caps form when available." />
      <item value="Overload for resolving lifecycle providers allows configuration of checking &quot;end&quot; boundaries of lifecycles. That is, they will ensure that the lifecycle has both started and not ended, and otherwise will throw one of LifecycleNotStartedException (if peekLifecycle returns null) or LifecycleEndedException if the lifecycle is ended. To configure the runtime behavior of these exceptions, see AutoDisposePlugins. Note: This resolves the scope immediately, so consider deferring execution as needed, such as using defer." />
      <item value="Calls the cancel Action if the downstream cancels the sequence. The action is shared between subscriptions and thus may be called concurrently from multiple threads; the action must be thread-safe. If the action throws a runtime exception, that exception is rethrown by the onCancel() call, sometimes as a CompositeException if there were multiple exceptions along the way. Note that terminal events trigger the action unless the Publisher is subscribed to via unsafeSubscribe()." />
      <item value="If an object of this type is attached to the text of a TextView with a movement method of LinkMovementMethod, the affected spans of text can be selected. If selected and clicked, the onClick method will be called. The text with a ClickableSpan attached will be underlined and the link color will be used as a text color. The default link color is the theme's accent color or android:textColorLink if this attribute is defined in the theme. For example, considering that we have a CustomClickableSpan that extends ClickableSpan, it can be used like this:" />
      <item value="use Real Size" />
      <item value="lumi 1.54 EF 44100035891 F" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1013" />
        <entry key="ENGLISH" value="1014" />
        <entry key="FRENCH" value="1" />
        <entry key="GERMAN" value="1" />
      </map>
    </option>
  </component>
</application>