<application>
  <component name="AppStorage">
    <histories>
      <item value="Represents a callable entity, such as a function or a property." />
      <item value="Visibility of this callable, or `null` if its visibility cannot be represented in Kotlin." />
      <item value="`true` if this callable is `open`." />
      <item value="Network is unreachable" />
      <item value="Binds the current process to {@code network}. All Sockets created in the future * (and not explicitly bound via a bound SocketFactory from * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to * {@code network}. All host name resolutions will be limited to {@code network} as well. * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to * work and all host name resolutions will fail. This is by design so an application doesn't * accidentally use Sockets it thinks are still bound to a particular {@link Network}. * To clear binding pass {@code null} for {@code network}. Using individually bound * Sockets created by Network.getSocketFactory().createSocket() and * performing network-specific host name resolutions via * {@link Network#getAllByName Network.getAllByName} is preferred to calling * {@code bindProcessToNetwork}." />
      <item value="Allow a previously configured network to be associated with. If * &lt;code&gt;attemptConnect&lt;/code&gt; is true, an attempt to connect to the selected * network is initiated. This may result in the asynchronous delivery * of state change events." />
      <item value="Untitled GraphQL Schema" />
      <item value="identify" />
      <item value="decryption failed" />
      <item value="execute" />
      <item value="maximum length of the returned packet. Equals to MTU-3. * Use {@link no.nordicsemi.android.ble.BleManager#requestMtu(int)} to request * higher MTU, or {@link no.nordicsemi.android.ble.BleManager#overrideMtu(int)} * If the MTU change was initiated by the target device." />
      <item value="外部" />
      <item value="resolve" />
      <item value="Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the * {@code timespan} argument. When the source Publisher completes, the resulting Publisher emits the current buffer * and propagates the notification from the source Publisher. Note that if the source Publisher issues an onError * notification the event is passed on immediately without first emitting the buffer it is in the process of * assembling." />
      <item value="Request a scan for access points. Returns immediately. The availability * of the results is made known later by means of an asynchronous event sent * on completion of the scan." />
      <item value="signal strength changed" />
      <item value="Broadcast intent action indicating that the configured networks changed." />
      <item value="An access point scan has completed, and results are available." />
      <item value="`true` if this property is `lateinit`." />
      <item value="This declaration can only be called on a reference to a lateinit property" />
      <item value="depending on the action, do necessary business logic calls and update the" />
      <item value="Returns a Single that emits a single HashMap containing all items emitted by the finite source Publisher, * mapped by the keys returned by a specified {@code keySelector} function." />
      <item value="URL resolved against the {@linkplain Retrofit#baseUrl() base URL}." />
      <item value="See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how * the value will be resolved against a base URL to create the full endpoint URL." />
      <item value="expect {, actual pos 51" />
      <item value="Callback called when the data received do not conform to required scheme." />
      <item value="Returns `true` if at least one element matches the given [predicate]." />
      <item value="Returns `true` if no elements match the given [predicate]." />
      <item value="This function will commit all queued up characteristic write * operations for a given remote device." />
      <item value="Executes a reliable write transaction for a given remote device." />
      <item value="Callback invoked when a reliable write transaction has been completed." />
      <item value="Reliable" />
      <item value="offer" />
      <item value="All methods defined in the super class." />
      <item value="Sets an optional retry count and a delay that the process will wait before each connection * attempt. The library will NOT retry if the device is not reachable, that is when the 30 sec. * timeout occurs. In that case the app should scan before connecting, to make sure the * target is in range." />
      <item value="Different PHYs are available only on more recent devices with Android 8+. * Check {@link BluetoothAdapter#isLe2MPhySupported()} and * {@link BluetoothAdapter#isLeCodedPhySupported()} if required PHYs are supported by this * Android device. The default PHY is {@link PhyRequest#PHY_LE_1M_MASK}." />
      <item value="Sets the preferred PHY used for connection. Th value should be a bitmask composed of" />
      <item value="Prefer the S=8 coding to be used when transmitting on the LE Coded PHY." />
      <item value="Bluetooth LE 2M PHY mask. Used to specify LE 2M Physical Channel as one of many available * options in a bitmask." />
      <item value="Bluetooth LE 1M PHY mask. Used to specify LE 1M Physical Channel as one of many available * options in a bitmask." />
      <item value="This method will be called if a remote device requires a non-'just works' pairing. * See PAIRING_* constants for possible options." />
      <item value="the handler used for delaying operations, timeouts and, most of all, the * request callbacks (done/fail/with, etc)." />
      <item value="Note that only one observer is going to be notified of changes." />
      <item value="This avoids a common problem with events: on configuration change (like rotation) an update * can be emitted if the observer is active. This LiveData only calls the observable if there's an * explicit call to setValue() or call()." />
      <item value="A lifecycle-aware observable that sends only new updates after subscription, used for events like * navigation and Snackbar messages." />
      <item value="Invalid" />
      <item value="Called when the data has been sent to the connected device." />
      <item value="不在范围内" />
      <item value="刻度" />
      <item value="undefined" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="446" />
        <entry key="ENGLISH" value="447" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>