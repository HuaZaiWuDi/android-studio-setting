<application>
  <component name="AppStorage">
    <histories>
      <item value="error: failed linking file resources." />
      <item value="abnormal" />
      <item value="AVATAR" />
      <item value="场景" />
      <item value="关联" />
      <item value=" behind" />
      <item value="Returns a Single that emits only the very first item emitted by this Observable or * signals a {@link NoSuchElementException} if this Observable is empty." />
      <item value="Returns a Single that emits only the very first item emitted by the source ObservableSource, or a default item * if the source ObservableSource completes without emitting any items." />
      <item value="One of the verbs defined by * {@link android.widget.RelativeLayout RelativeLayout}, such as * ALIGN_WITH_PARENT_LEFT." />
      <item value="场景面板" />
      <item value="Negative" />
      <item value="Returns true if the final {@link #onDestroy()} call has been made * on the Activity, so this instance is now dead." />
      <item value="Category" />
      <item value="Bonjour" />
      <item value="Starts a Bonjour service discovery for the provided service type with the given {@link Driver}. * &lt;p&gt; * The stream will immediately end with an {@link IllegalBonjourTypeException} * if the input type does not obey Bonjour type specifications. * If you intend to use this method with arbitrary types that can be provided by user input, * it is highly encouraged to verify this input * using {@link #isBonjourType(String)} &lt;b&gt;before&lt;/b&gt; calling this method!" />
      <item value="confirm" />
      <item value="If true, delivers the most recent sticky event (posted with * {@link EventBus#postSticky(Object)}) to this subscriber (if event available)." />
      <item value="Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}." />
      <item value="m Pos Dev Service Name Format Pattern" />
      <item value="Indicates that the operation failed because it is already active." />
      <item value="* The lookup key for an int that indicates whether network service discovery is enabled * or disabled. Retrieve it with {@link android.content.Intent#getIntExtra(String,int)}." />
      <item value="COMMAND" />
      <item value="An Effect that positionally memoizes the result of a computation." />
      <item value="None of the following functions can be called with the arguments supplied:" />
      <item value="After successful service discovery the service will initialize all services. * The {@link #onDeviceReady(BluetoothDevice)} method will be called when the initialization * is complete." />
      <item value="if &lt;code&gt;true&lt;/code&gt; the secondary services were also found * on the device." />
      <item value="GATT CONN TERMINATE LOCAL HOST" />
      <item value="thread is not runnable for too long time, need to remove" />
      <item value="Called each time the task queue gets cleared." />
      <item value="Set the 'operation in progress' flag, so any request made in onDeviceReady() // will not start new nextRequest() call." />
      <item value="after {@link BleManagerCallbacks#onDeviceReady(BluetoothDevice)} has been * called." />
      <item value="This method returns a {@link ConnectRequest} which can be used to set completion * and failure callbacks. The completion callback (done) will be called after the initialization * is complete, after {@link BleManagerCallbacks#onDeviceReady(BluetoothDevice)} has been * called." />
      <item value="is called in notifyDeviceDisconnected, which may enqueue new requests. // Setting this flag to false would allow to enqueue a new request before the // current one ends processing. The following line should not be uncommented." />
      <item value="Executes the next request. If the last element from the initialization queue has * been executed the {@link #onDeviceReady()} callback is called." />
      <item value="Callback indicating the connection parameters were updated. Works on Android 8+." />
      <item value="This method is called from the main thread when the services has been discovered and * the device is supported (has required service)." />
      <item value="This method should set up the request queue needed to initialize the profile. * Enabling Service Change indications for bonded devices is handled before executing this * queue. The queue may have requests that are not available, e.g. read an optional * service when it is not supported by the connected device. Such call will trigger * {@link Request#fail(FailCallback)}." />
      <item value="Chain of Causes for CompositeException In Order Received" />
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or its parent has been &quot;activated&quot; meaning the user has currently marked it as being of interest. This is an alternative representation of state_checked for when the state should be propagated down the view hierarchy." />
      <item value="State value for {@link android.graphics.drawable.StateListDrawable StateListDrawable}, set when a view or drawable is in the last position in an ordered set. Actual usage may vary between views. Consult the host view documentation for details." />
      <item value="The specified child already has a parent. You must call removeView() on the child's parent first." />
      <item value="Creates a {@link ViewModelProvider}, which retains ViewModels while a scope of given * {@code fragment} is alive. More detailed explanation is in {@link ViewModel}." />
      <item value="Enqueues the given request at the front of the the init or task queue, depending * on whether the initialization is in progress, or not." />
      <item value="An instance of a request that waits for a notification or an indication. * There may be only a single instance of such request at a time as this is a blocking request." />
      <item value="Allow new requests when Bluetooth is enabled again. close() doesn't do it." />
      <item value="On older Android versions, after executing a command on secured attribute // of a device that is not bonded, let's say a write characteristic operation, // the system will start bonding. The BOND_BONDING and BOND_BONDED events will // be received, but the command will not be repeated automatically." />
      <item value="This method will be called if a remote device requires a non-'just works' pairing. * See PAIRING_* constants for possible options." />
      <item value="Device discovery is a heavyweight procedure. New connections to * remote Bluetooth devices should not be attempted while discovery is in * progress, and existing connections will experience limited bandwidth * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing * discovery. Discovery is not managed by the Activity, * but is run as a system service, so an application should always call * {@link BluetoothAdapter#cancelDiscovery()} even if it * did not directly request a discovery, just to be sure. * &lt;p&gt;Device discovery will only find remote devices that are currently * &lt;i&gt;discoverable&lt;/i&gt; (inquiry scan enabled). Many Bluetooth devices are * not discoverable by default, and need to be entered into a special mode. * &lt;p&gt;If Bluetooth state is not {@link #STATE_ON}, this API * will return false. After turning on Bluetooth, * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON} * to get the updated value." />
      <item value="The discovery process usually involves an inquiry scan of about 12 * seconds, followed by a page scan of each new device to retrieve its * Bluetooth name. * &lt;p&gt;This is an asynchronous call, it will return immediately. Register * for {@link #ACTION_DISCOVERY_STARTED} and {@link * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the * discovery starts and completes. Register for {@link * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices * are found." />
      <item value="Start the remote device discovery process." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="85" />
        <entry key="ENGLISH" value="86" />
        <entry key="FRENCH" value="2" />
        <entry key="JAPANESE" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
</application>