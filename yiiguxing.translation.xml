<application>
  <component name="AppStorage">
    <histories>
      <item value="Adds or subtracts the specified amount of time to the given calendar field, * based on the calendar's rules. For example, to subtract 5 days from * the current time of the calendar, you can achieve it by calling:" />
      <item value="access" />
      <item value="The notification starts the callback and loads more */" />
      <item value="Continuous" />
      <item value="Timer" />
      <item value="timer" />
      <item value="times" />
      <item value="time" />
      <item value="连续" />
      <item value="cl sms Log" />
      <item value="Manual" />
      <item value="log" />
      <item value="Log" />
      <item value="detection" />
      <item value="privacy protection" />
      <item value="Check the device conditions for Smart Security\n&quot; + &quot;[Myhome door sensor] It is opened.\n&quot; + &quot;[Myhome motion sensor] Network connection is failed.\n&quot; + &quot;Will you activate Myguard Smart Security?" />
      <item value="Motion" />
      <item value="Reasons" />
      <item value="All security devices are offline" />
      <item value="Returns a Single that emits the single item emitted by this Observable if this Observable * emits only a single item, otherwise * if this Observable completes without emitting any items or emits more than one item a * {@link NoSuchElementException} or {@code IllegalArgumentException} will be signalled respectively." />
      <item value="Normally, an ObservableSource that returns multiple items will do so by invoking its {@link Observer}'s * {@link Observer#onNext onNext} method for each such item. You can change this behavior, instructing the * ObservableSource to compose a list of all of these items and then to invoke the Observer's {@code onNext} * function once, passing it the entire list, by calling the ObservableSource's {@code toList} method prior to * calling its {@link #subscribe} method." />
      <item value="a Single that emits a single item: a List containing all of the items emitted by the source * ObservableSource" />
      <item value="Bonjour" />
      <item value="an Observable that emits only those items emitted by the source ObservableSource that the filter * evaluates as {@code true}" />
      <item value="Returns a Single that emits a single item, a list composed of all the items emitted by the * finite source ObservableSource." />
      <item value="the period of time each buffer collects items before it is emitted and replaced with a new * buffer" />
      <item value="When inputting prohibited specific characters" />
      <item value="round" />
      <item value="Specific" />
      <item value="Autowired" />
      <item value="Fields from build type: debug" />
      <item value="solve" />
      <item value="原始" />
      <item value="原始的" />
      <item value="Changed" />
      <item value="Set a special listener to be called when an action is performed * on the text view. This will be called when the enter key is pressed, * or when an action supplied to the IME is selected by the user. Setting * this means that the normal hard key event will not insert a newline * into the text view, even if it is multi-line; holding down the ALT * modifier will, however, allow the user to insert a newline character." />
      <item value="Returns whether the soft input method will be made visible when this * TextView gets focused. The default is true." />
      <item value="Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order." />
      <item value="m Dispatching" />
      <item value="dispatching" />
      <item value="Adds the given observer to the observers list. This call is similar to * {@link LiveData#observe(LifecycleOwner, Observer)} with a LifecycleOwner, which * is always active. This means that the given observer will receive all events and will never * be automatically removed. You should manually call {@link #removeObserver(Observer)} to stop * observing this LiveData. * While LiveData has one of such observers, it will be considered * as active." />
      <item value="Absent" />
      <item value="Posts a task to a main thread to set the given value. So if you have a following code * executed in the main thread:" />
      <item value="If you called this method multiple times before a main thread executed a posted task, only * the last value would be dispatched." />
      <item value="The value &quot;b&quot; would be set at first and later the main thread would override it with * the value &quot;a&quot;." />
      <item value="Called when the number of active observers change to 1 from 0." />
      <item value="Sets the value. If there are active observers, the value will be dispatched to them." />
      <item value="This method must be called from the main thread. If you need set a value from a background * thread, you can use {@link #postValue(Object)}" />
      <item value="message" />
      <item value="massage" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="264" />
        <entry key="ENGLISH" value="265" />
        <entry key="FRENCH" value="4" />
        <entry key="CATALAN" value="1" />
        <entry key="ZULU" value="1" />
        <entry key="JAPANESE" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>