<application>
  <component name="AppStorage">
    <histories>
      <item value="Demonstrates use of RenderScript to display a live HDR feed from camera frames using Camera2 API." />
      <item value="Adds another {@link MeteringPoint} with default metering mode {@link #FLAG_AF} | * {@link #FLAG_AE} | {@link #FLAG_AWB}." />
      <item value="When the torch is enabled, the torch will remain enabled during photo capture regardless * of the flashMode setting. When the torch is disabled, flash will function as the flash mode * set by either {@link ImageCapture#setFlashMode(int)} or * {@link ImageCapture.Builder#setFlashMode(int)}." />
      <item value="The viewPort which represents the visible camera sensor rect." />
      <item value="Unbinds all specified use cases from the lifecycle." />
      <item value="It modifies both current zoomRatio and linearZoom so if apps are observing * zoomRatio or linearZoom, they will get the update as well. If the ratio is * smaller than {@link ZoomState#getMinZoomRatio()} or larger than * {@link ZoomState#getMaxZoomRatio()}, the returned {@link ListenableFuture} will fail with * {@link IllegalArgumentException} and it won't modify current zoom ratio. It is the * applications' duty to clamp the ratio." />
      <item value="Sets current zoom by ratio." />
      <item value="Set the exposure compensation value for the camera." />
      <item value="Torch" />
      <item value="When the torch is enabled via {@link CameraControl#enableTorch(boolean)}, the torch * will remain enabled during photo capture regardless of flashMode setting. When * the torch is disabled, flash will function as specified by {@link #setFlashMode(int)}." />
      <item value="Returns if flash unit is available or not." />
      <item value="The flash control for the subsequent photo capture requests. Applications can check if * there is a flash unit via {@link CameraInfo#hasFlashUnit()} and update UI component if * necessary. If there is no flash unit, then calling this API will take no effect for the * subsequent photo capture requests and they will act like {@link #FLASH_MODE_OFF}." />
      <item value="Auto flash. The flash will be used according to the camera system's determination when taking * a picture." />
      <item value="Constant emission of light during preview, auto-focus and snapshot. * This can also be used for video recording." />
      <item value="Always flash. The flash will always be used when taking a picture." />
      <item value="UNAVAILABLE" />
      <item value="重" />
      <item value="重新扫描" />
      <item value="rescan" />
      <item value="InputImage width and height should be at least 32!" />
      <item value="re Scan" />
      <item value="The specified child already has a parent. You must call removeView() on the child's parent first." />
      <item value="container" />
      <item value="If the folder selected is an external media directory, this is unnecessary but otherwise other apps will not be able to access our images unless we scan them using [MediaScannerConnection]" />
      <item value="Image capture scanned into media store" />
      <item value="Callers should migrate to inserting items directly into * {@link MediaStore}, where they will be automatically scanned * after each mutation." />
      <item value="Broadcast Action: Request the media scanner to scan a file and add it to * the media database." />
      <item value="MediaScannerConnection provides a way for applications to pass a newly created or downloaded media file to the media scanner service The media scanner service will read metadata from the file and add the file to the media content provider. The MediaScannerConnectionClient provides an interface for the media scanner service to return the Uri for a newly scanned file to the client of the MediaScannerConnection class." />
      <item value="LENS FACING FRONT" />
      <item value="Optimizes capture pipeline to prioritize latency over image quality. When the capture * mode is set to MIN_LATENCY, images may capture faster but the image quality may be * reduced." />
      <item value="The executor in which the callback methods will be run." />
      <item value="Returns the set capture mode." />
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics." />
      <item value="Requires a camera with the specified lens facing." />
      <item value="Lens Facing" />
      <item value="Waits if necessary for at most the given time for the computation * to complete, and then retrieves its result, if available." />
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX. * * &lt;p&gt;This will initiate a close of every currently open camera." />
      <item value="Allows shutting down this {@link ProcessCameraProvider} instance so a new instance can be * retrieved by {@link #getInstance(Context)}." />
      <item value="Users can call {@link #createPoint(float, float)} to * create a {@link MeteringPoint} with x, y, default size. There is also another * variant, {@link #createPoint(float, float, float)} for apps that want to also specify size." />
      <item value="x to be converted." />
      <item value="The width/height is the width/height in surface orientation which defines an area (0, 0) * - (width, height) within which apps can specify metering points by * {@link #createPoint(float, float)}. Setting width and height to 1.0 will allow points to * be created by specifying normalized coordinates." />
      <item value="Creates the {@link SurfaceOrientedMeteringPointFactory} by width and height" />
      <item value="If more points are added than what current device supports for AF/AE/AWB, only the * first point and then in order up to the number of points supported on the device * will be enabled." />
      <item value="The points added here will be appended in order after the point set in builder * constructor." />
      <item value="&lt;p&gt;Metering mode is a combination of flags consisting of {@link #FLAG_AF}, * {@link #FLAG_AE}, and {@link #FLAG_AWB}. This combination indicates whether the * {@link MeteringPoint} is used to set AF(Auto Focus) region, AE(Auto Exposure) region * or AWB(Auto White Balance) region." />
      <item value="Adds another {@link MeteringPoint} with specified meteringMode." />
      <item value="A flag used in metering mode indicating the AF (Auto Focus) region is enabled. An autofocus * scan is also triggered when FLAG_AF is assigned." />
      <item value="A flag used in metering mode indicating the AWB (Auto White Balance) region is enabled." />
      <item value="A flag used in metering mode indicating the AE (Auto Exposure) region is enabled." />
      <item value="&lt;p&gt; This is used to apply additional configs that modifying the behavior of the camera and any attached {@link UseCase}. For example, this may limit the instances of CameraInternal that are used or configure the {@link ImageCapture} to use a {@link androidx.camera.core.impl.CaptureProcessor} in order to implement effects such as HDR or bokeh." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1598" />
        <entry key="ENGLISH" value="1599" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>