<application>
  <component name="AppStorage">
    <histories>
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics." />
      <item value="Requires a camera with the specified lens facing." />
      <item value="Lens Facing" />
      <item value="Waits if necessary for at most the given time for the computation * to complete, and then retrieves its result, if available." />
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX. * * &lt;p&gt;This will initiate a close of every currently open camera." />
      <item value="Allows shutting down this {@link ProcessCameraProvider} instance so a new instance can be * retrieved by {@link #getInstance(Context)}." />
      <item value="Users can call {@link #createPoint(float, float)} to * create a {@link MeteringPoint} with x, y, default size. There is also another * variant, {@link #createPoint(float, float, float)} for apps that want to also specify size." />
      <item value="x to be converted." />
      <item value="The width/height is the width/height in surface orientation which defines an area (0, 0) * - (width, height) within which apps can specify metering points by * {@link #createPoint(float, float)}. Setting width and height to 1.0 will allow points to * be created by specifying normalized coordinates." />
      <item value="Creates the {@link SurfaceOrientedMeteringPointFactory} by width and height" />
      <item value="If more points are added than what current device supports for AF/AE/AWB, only the * first point and then in order up to the number of points supported on the device * will be enabled." />
      <item value="The points added here will be appended in order after the point set in builder * constructor." />
      <item value="&lt;p&gt;Metering mode is a combination of flags consisting of {@link #FLAG_AF}, * {@link #FLAG_AE}, and {@link #FLAG_AWB}. This combination indicates whether the * {@link MeteringPoint} is used to set AF(Auto Focus) region, AE(Auto Exposure) region * or AWB(Auto White Balance) region." />
      <item value="Adds another {@link MeteringPoint} with specified meteringMode." />
      <item value="A flag used in metering mode indicating the AF (Auto Focus) region is enabled. An autofocus * scan is also triggered when FLAG_AF is assigned." />
      <item value="A flag used in metering mode indicating the AWB (Auto White Balance) region is enabled." />
      <item value="A flag used in metering mode indicating the AE (Auto Exposure) region is enabled." />
      <item value="&lt;p&gt; This is used to apply additional configs that modifying the behavior of the camera and any attached {@link UseCase}. For example, this may limit the instances of CameraInternal that are used or configure the {@link ImageCapture} to use a {@link androidx.camera.core.impl.CaptureProcessor} in order to implement effects such as HDR or bokeh." />
      <item value="&lt;p&gt; This is used to apply additional configs that modifying the behavior of the camera and * any attached {@link UseCase}. For example, this may limit the instances of CameraInternal * that are used or configure the {@link ImageCapture} to use a * {@link androidx.camera.core.impl.CaptureProcessor} in order to implement effects such as * HDR or bokeh." />
      <item value="&lt;p&gt; A {@link Camera} is a logical camera which wraps one or more {@link CameraInternal}. * At any time, only one of the CameraInternal is actually being used, and it is up to the * implementation to determine which {@link CameraInternal} will be used. Certain * reconfigurations of the camera will cause the current CameraInternal camera to change. * However, it will be transparent to the {@link CameraControl} and {@link CameraInfo} * retrieved from {@link #getCameraControl()} and {@link #getCameraInfo()}." />
      <item value="Returns all of the {@link CameraInternal} instances represented by this Camera." />
      <item value="&lt;p&gt;The {@link CameraControl} provides various asynchronous operations like zoom, focus and * metering. {@link CameraControl} is ready to start operations immediately after use cases * are bound to the {@link Camera}. When all {@link UseCase}s are unbound, or when camera is * closing or closed because lifecycle onStop happens, the {@link CameraControl} will reject * all operations." />
      <item value="Returns information about this camera." />
      <item value="Set the extended config of the Camera and potentially reconfigure the camera." />
      <item value="Get the currently set extended config of the Camera." />
      <item value="Enable the torch or disable the torch." />
      <item value="Starts a focus and metering action configured by the {@link FocusMeteringAction}." />
      <item value="Captures a new still image for in memory access." />
      <item value="Unbinds all use cases from the lifecycle and removes them from CameraX." />
      <item value="Portrait" />
      <item value="Adds a {@link CameraFilter} to the current set of filters. It can be used to select a * specific camera based on customized criteria like Camera2 characteristics. * * &lt;p&gt;Multiple filters can be added. All filters will be applied by the order they were * added when the {@link CameraSelector} is used, and the first camera output from the * filters will be selected." />
      <item value="A {@link Future} that accepts completion listeners. Each listener has an associated executor, and * it is invoked using this executor once the future's computation is {@linkplain Future#isDone() * complete}. If the computation has already completed when the listener is added, the listener will * execute immediately. *" />
      <item value="&lt;p&gt;When the producer stops producing images, it may also stop producing images for other use cases, such as {@link Preview}, so it is important for the analyzer to keep up with frame rate, &lt;i&gt;on average&lt;/i&gt;. Failure to keep up with frame rate may lead to jank in the frame stream and a diminished user experience. If more time is needed for analysis on &lt;i&gt;some&lt;/i&gt; frames, consider increasing the image queue depth with {@link Builder#setImageQueueDepth(int)}." />
      <item value="&lt;p&gt;Once the producer has produced the number of images equal to the image queue depth, and none have been closed, the producer will stop producing images. Note that images may be queued internally and not be delivered to the analyzer until the last delivered image has been closed with {@link ImageProxy#close()}. These internally queued images will count towards the total number of images that the producer can provide at any one time." />
      <item value="&lt;p&gt;This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. Only one image will be delivered for analysis at a time. If more images are produced while that image is being analyzed, they will be dropped and not queued for delivery. Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the next latest image will be delivered." />
      <item value="Block the producer from generating new images." />
      <item value="PRODUCER" />
      <item value="&gt;The available values are {@link #STRATEGY_BLOCK_PRODUCER} and * {@link #STRATEGY_KEEP_ONLY_LATEST}. * * &lt;p&gt;If not set, the backpressure strategy will default to * {@link #STRATEGY_KEEP_ONLY_LATEST}. *" />
      <item value="This strategy ignores the value set by {@link Builder#setImageQueueDepth(int)}. * Only one image will be delivered for analysis at a time. If more images are produced * while that image is being analyzed, they will be dropped and not queued for delivery. * Once the image being analyzed is closed by calling {@link ImageProxy#close()}, the * next latest image will be delivered." />
      <item value="Only deliver the latest image to the analyzer, dropping images as they arrive" />
      <item value="Once the producer has produced the number of images equal to the image queue depth, * and none have been closed, the producer will stop producing images. Note that images * may be queued internally and not be delivered to the analyzer until the last delivered * image has been closed with {@link ImageProxy#close()}. These internally queued images * will count towards the total number of images that the producer can provide at any one * time." />
      <item value="The requested capture processor for extension." />
      <item value="Processor" />
      <item value="Turn on the local Bluetooth adapter&amp;mdash;do not use without explicit user action to turn on Bluetooth. &lt;p&gt;This powers on the underlying Bluetooth hardware, and starts all Bluetooth system services. &lt;p class=&quot;caution&quot;&gt;&lt;strong&gt;Bluetooth should never be enabled without direct user consent&lt;/strong&gt;. If you want to turn on Bluetooth in order to create a wireless connection, you should use the {@link #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests user permission to turn on Bluetooth. The {@link #enable()} method is provided only for applications that include a user interface for changing system settings, such as a &quot;power manager&quot; app.&lt;/p&gt; &lt;p&gt;This is an asynchronous call: it will return immediately, and clients should listen for {@link #ACTION_STATE_CHANGED} to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from {@link #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time later transition to either {@link #STATE_OFF} or {@link #STATE_ON}. If this call returns false then there was an immediate problem that will prevent the adapter from being turned on - such as Airplane mode, or the adapter is already turned on." />
      <item value="Turn on the local Bluetooth adapter&amp;mdash;do not use without explicit * user action to turn on Bluetooth." />
      <item value="rationale" />
      <item value="Some privileges permanently disabled, may need to set up in the execute." />
      <item value="Handle overlay permission." />
      <item value="不支持" />
      <item value="Do your init work in this method, it well be call when processor has been load." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1566" />
        <entry key="ENGLISH" value="1567" />
        <entry key="FRENCH" value="1" />
        <entry key="KOREAN" value="92" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>